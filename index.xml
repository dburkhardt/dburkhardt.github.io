<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Krishnaswamy Lab on Krishnaswamy Lab</title>
    <link>https://dburkhardt.github.io/</link>
    <description>Recent content in Krishnaswamy Lab on Krishnaswamy Lab</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2019 Krishnaswamy Lab</copyright>
    <lastBuildDate>Wed, 20 Apr 2016 00:00:00 -0400</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Denoising and imputing scRNA-seq data</title>
      <link>https://dburkhardt.github.io/post/2018-10-28-magic/</link>
      <pubDate>Sun, 28 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://dburkhardt.github.io/post/2018-10-28-magic/</guid>
      <description>

&lt;h1 id=&#34;part-1-the-problem&#34;&gt;Part 1: The problem&lt;/h1&gt;

&lt;p&gt;Single cell RNA-sequencing (scRNA-seq) is an increasingly popular method for measuring transcriptome-wide gene expression in single cells. However, there are several technical challenges that make analysing scRNA-seq data difficult. One of the biggest hurdles stems from the fact that of the roughly 100,000-300,000 mRNAs in a cell, only 10-40% are captured using current scRNA-seq protocols &lt;a href=&#34;https://www.ncbi.nlm.nih.gov/pubmed/24919153&#34; title=&#34;Single-cell RNA-seq reveals dynamic paracrine control of cellular variation.&#34; target=&#34;_blank&#34;&gt;[1]&lt;/a&gt;, &lt;a href=&#34;https://www.ncbi.nlm.nih.gov/pubmed/24141493&#34; title=&#34;Quantitative assessment of single-cell RNA-sequencing methods.&#34; target=&#34;_blank&#34;&gt;[2]&lt;/a&gt;, &lt;a href=&#34;https://www.ncbi.nlm.nih.gov/pubmed/22939981&#34; title=&#34;CEL-Seq: single-cell RNA-Seq by multiplexed linear amplification.&#34; target=&#34;_blank&#34;&gt;[3]&lt;/a&gt;, &lt;a href=&#34;https://www.ncbi.nlm.nih.gov/pubmed/21543516&#34; title=&#34;Characterization of the single-cell transcriptional landscape by highly multiplex RNA-seq.&#34; target=&#34;_blank&#34;&gt;[4]&lt;/a&gt;. As a result, all genes in all cells are undercounted, and lowly expressed genes may be recorded at 0s in the gene expression matrix despite being expressed.&lt;/p&gt;

&lt;p&gt;This undercounting adds several hurdles to the analysis of scRNA-seq data that do not exist for bulk-RNA sequencing. In this post, we will first discuss a few of these hurdles (in part 1) and then how they can be addressed using MAGIC (in part 2), our recently published data denoising and imputation method.&lt;/p&gt;

&lt;p&gt;In part 1 we will discuss the following:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Why are molecules undersampled in scRNA-seq?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;How does undercounting/dropout obscure biology?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;How can imputation solve these problems?&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;rt-inefficiency-leads-to-undercounting-genes-and-dropout&#34;&gt;RT inefficiency leads to undercounting genes and “dropout”&lt;/h3&gt;

&lt;p&gt;As we mentioned above, only 10-40% of the transcripts in a given cell are captured in current scRNA-seq methods. For the most part, this is because doing the first round of reverse transcription (RT) and subsequent PCR amplification in the presence of cell lysate in nanoliter droplets is not very efficient. As a result, it’s better to think of scRNA-seq as a sampling method, as opposed to bulk RNA-sequencing which is more akin to a census or counting method.&lt;/p&gt;

&lt;p&gt;In the MAGIC paper, we showed what this looks like. It’s hard to establish a “ground truth” for single cell data, so we picked &lt;a href=&#34;https://www.ncbi.nlm.nih.gov/pubmed/24270809&#34; title=&#34;The effects of genetic variation on gene expression dynamics during development.&#34; target=&#34;_blank&#34;&gt;a large bulk C. elegans time course&lt;/a&gt; and simulated a 20% mRNA capture efficiency by down-sampling molecules in the dataset. On the left is the original data for 9861 genes in 206 worms, and the right is the simulated undercounted data.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dburkhardt.github.io/2018-10-28-magic/worms.png&#34; alt=&#34;Worms&#34; /&gt;&lt;/p&gt;

&lt;p&gt;As you can see, there are a lot of zero values. The question is, are some zeros different from others?&lt;/p&gt;

&lt;p&gt;When reading about scRNA-seq, it’s difficult to avoid the word “dropout.” It’s even harder to find a consistent definition of the term. The most common definition we’ve come across refers to when a gene is lowly expressed, say in the range of 1-20 molecules / cell. Now if you’re only capturing 10% of all molecules in a cell, and assume this sampling follows a negative binomial distribution, you will find that in many cells 0 unique reads will be observed &lt;strong&gt;despite the gene being expressed&lt;/strong&gt;. This “observed as 0, but present” is termed dropout or a technical zero. This is opposed to a gene that just isn’t expressed in that cell, which is called a true or biological zero.&lt;/p&gt;

&lt;p&gt;We will get more into this later, but we think it’s a bad idea to think about dropout as a problem only affecting lowly expressed genes because &lt;strong&gt;undercounting happens to all genes regardless of expression&lt;/strong&gt;. It just so happens that for lowly expressed genes, undercounting leads to an observation of 0. This is fundamentally different from a problem where there are missing values that might be recorded as 0, such as &lt;a href=&#34;https://en.wikipedia.org/wiki/Netflix_Prize&#34; title=&#34;Netflix Prize&#34; target=&#34;_blank&#34;&gt;the Netflix Problem&lt;/a&gt;. In the case of missing values, you know what you don’t know, and there exist very efficient and elegant methods to solve this problem, such as nuclear norm matrix completion. With scRNA-seq, we’re dealing with unknown unknowns.&lt;/p&gt;

&lt;p&gt;To illustrate this, see the three matrices below. The left is the original data matrix, the middle matrix is undercounted, i.e. 80% of the molecules are not counted so values are undercounted, in the third matrix 80% of the entries are set to zero. In scRNA-seq, undercounting produces a gene expression matrix more like the middle matrix where every entry can be affected.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dburkhardt.github.io/2018-10-28-magic/matrices.png&#34; alt=&#34;Matrices&#34; /&gt;&lt;/p&gt;

&lt;p&gt;There are many complex processes that add noise to gene expression data in scRNA-seq. We would like to note here that MAGIC makes no attempt to explicitly model these processes or assume a particular data-generating distribution. Instead, MAGIC assumes that gene expression in scRNA-seq follows the smoothness assumption. That is, we assume that the close neighbors of a cell contain gene expression information that can be used to recover information lost to undercounting in that cell. We’ll discuss this further in part 2 of this post.&lt;/p&gt;

&lt;h3 id=&#34;undercounting-rna-molecules-obscures-biology&#34;&gt;Undercounting RNA molecules obscures biology&lt;/h3&gt;

&lt;p&gt;It’s not hard to imagine that dealing with data missing 90% of counts is a problem. Indeed, working with raw scRNA-seq data is a challenge - many biological signals are obscured and many types of analyses are impossible to do on sparse data. For example, dropout obscures gene-gene relationships. To illustrate this let’s look at the following two gene-gene scatterplots of an EMT dataset that we presented in the MAGIC paper:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dburkhardt.github.io/2018-10-28-magic/EMT_edges.png&#34; alt=&#34;EMT edges&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We expect Vimentin and E-Cadherin to be negatively correlated, since Vimentin is a mesenchymal marker and E-Cadherin is an epithelial marker. However, due to the undercounting, this relationship is not apparent. Similarly, we expect Vimentin and Snail to be positively correlated as Snail is a TF involved in regulation of the mesenchymal state.&lt;/p&gt;

&lt;h3 id=&#34;how-can-we-overcome-undercounting&#34;&gt;How can we overcome undercounting?&lt;/h3&gt;

&lt;p&gt;Although we observe a small sample of mRNAs in a cell, many genes are redundant. Sets of transcription factors regulate modules of genes together. This means that the underlying gene expression state space is inherently low-dimensional and the feature set is not truly independent. However, we’re still left with the problem of figuring out how to use this inter-dependency of genes to recover undercounted gene expression.&lt;/p&gt;

&lt;h1 id=&#34;part-2-magic&#34;&gt;Part 2: MAGIC&lt;/h1&gt;

&lt;p&gt;In part 1, we wrote about how technical challenges in scRNA-seq lead to a phenomenon that we’re calling undercounting. Because of inefficiencies in mRNA capture, the counts for all genes in each cell of a gene expression matrix represent a subsample of all mRNAs present in that cell. Here, we will introduce our solution to this problem, called MAGIC, and discuss its practical application to scRNA-seq data.&lt;/p&gt;

&lt;p&gt;Specifically, we will discuss:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;How MAGIC recovers gene expression lost to dropout&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Interpretation of non-zero values after MAGIC&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Selecting optimal diffusion time for MAGIC&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Does MAGIC mix clusters?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Minimum cell numbers for MAGIC&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Where does MAGIC fit in your pipeline&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;magic&#34;&gt;MAGIC&lt;/h3&gt;

&lt;p&gt;In our recent paper &lt;a href=&#34;https://www.ncbi.nlm.nih.gov/pubmed/29961576&#34; title=&#34;Recovering Gene Interactions from Single-Cell Data Using Data Diffusion.&#34; target=&#34;_blank&#34;&gt;Recovering Gene Interactions from Single-Cell Data Using Data Diffusion&lt;/a&gt;, we propose a data imputation and denoising algorithm called MAGIC (Markov Affinity-based Graph Imputation of Cells). The idea of MAGIC is that we first learn the underlying structure, or manifold, of the data, and then recover the gene values using this manifold. To do this, MAGIC uses a cell-cell affinity graph to construct a Markov diffusion operator that is then used to diffuse data between cells, in the process filling in missing values and generally denoising the data.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dburkhardt.github.io/2018-10-28-magic/graphical_abstract.png&#34; alt=&#34;Graphical abstract&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;low-pass-filter-on-the-manifold&#34;&gt;Low-pass filter on the manifold&lt;/h3&gt;

&lt;p&gt;MAGIC has two parts: 1) learning the underlying structure, or manifold, of the data, and 2) imputing and denoising the gene counts by filtering them as signals on this manifold.&lt;/p&gt;

&lt;p&gt;For part 1 we first compute a cell-cell Markov affinity matrix. This matrix is a diffusion operator and we can take powers of this operator to perform a random walk on the graph. This enables us to learn the manifold of the data without making any assumptions about its shape.&lt;/p&gt;

&lt;p&gt;For part 2 we consider genes to be signals on the graph and we low-pass filter them by multiplying the powered diffusion operator with the genes. The result is a denoised and imputed data matrix.&lt;/p&gt;

&lt;p&gt;Another way to look at this process is in terms of graph signal processing. Powering the operator effectively performs a low pass filter on the spectrum of the graph. In a future blog post we will go deeper into understanding this, but briefly this means that we are eliminating high frequency dimensions from the graph. Since high frequency is associated with noise, including dropout, this effectively denoises and imputes the data.&lt;/p&gt;

&lt;h3 id=&#34;dropout-versus-biological-zeros&#34;&gt;Dropout versus biological zeros&lt;/h3&gt;

&lt;p&gt;We often get the question: “Does MAGIC remove all zeros? Even if they’re actual biological zeros?” The answer is yes AND no! The reason is that MAGIC effectively computes a neighborhood (in a non-linear way and on the manifold) and then exchanges values between neighboring cells. If, for some gene, all the neighbors have zero value, then after diffusion (data exchange) the values will still be zero. In this case we can conclude that we were dealing with a ‘real’ biological zero. If some of the neighbors were non-zero for this gene, then after diffusion all cells in the neighborhood will end up with a non-zero value. In this case the zeros were due to dropout. However, there is one caveat. In practice, due to the many steps of diffusion, it can be that after diffusion we end up with a small but non-zero value. One could naively interpret this as a non-biological zero that was due to dropout. This is not the case, and small non-zero values are still effectively biological zeros. Therefore, we recommend to not (only) look at the absolute values after imputation, but also at the relative values or distributions. In the figure below we show an example where after MAGIC there is a population of cells that, while not absolutely zero, effectively has no expression for the gene.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dburkhardt.github.io/2018-10-28-magic/zebrafish.png&#34; alt=&#34;Zebrafish&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In the above figure we can see gene expression after magic in five cell types of the zebrafish embryo from Wagner et al (2018). In red is gene expression of cells from embryos in which chordin was knocked out using Cas9. In blue is the expression from control embryos. We can see that expression of myod1 is effectively 0 for some populations of cells in the forming somites and somites. Similarly, tbx6 is effectively note expressed in early or late adaxial cells. Although close inspection shows expression of these genes is slightly above 0, we can infer that this gene is not expressed in these cells.&lt;/p&gt;

&lt;h3 id=&#34;optimal-diffusion-time&#34;&gt;Optimal diffusion time&lt;/h3&gt;

&lt;p&gt;In MAGIC we perform data diffusion by powering the Markov diffusion operator. The number of times we power, and thus number of steps we walk, is called the diffusion time and is denoted by the parameter t. The diffusion time controls the extent of the low pass filtering - the higher the t, the fewer eigenvectors are left. t is probably the most important parameter in MAGIC and should therefore be chosen carefully. In order to ensure an optimal value of t we provide (by default) an automatic method for picking it. This method is based on the idea that as we diffuse the data changes and that the rate of change of the data reflects what kind of signal we are altering. There are two types of signals in the data, the biological signal and the noise. The former is a low frequency signal and the latter a high frequency signal. As we diffuse, we first remove the high frequency noise and we observe a rapid change in the data. After a number of diffusion steps we enter the data (non-noise) regime and as a result the change in data is much slower. The goal is to set t to be right at this regime change, such that we have removed most noise but not the actual biologically meaningful signal. By quantifying the change in data (||data_t - data_t-1||) as a function of t we can find the regime change by picking t at the elbow point.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dburkhardt.github.io/2018-10-28-magic/norm_magic.gif&#34; alt=&#34;Normalized MAGIC&#34; /&gt;
&lt;em&gt;Visualization of cadherin, vimentin and zeb1 from the EMT dataset in the MAGIC paper.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;manual-diffusion-time&#34;&gt;Manual diffusion time&lt;/h3&gt;

&lt;p&gt;Our automatic diffusion time method is designed to pick a value of t that removes most of the noise but doesn’t remove much real biological signal. However, sometimes a user may want to do more diffusion for example when the data is especially noisy, and sacrifice some of the signal in return for more denoising. Conversely, a user may not want to sacrifice any biological signal and want less diffusion. In these cases we advise to first run automatic t selection and then manually choose a t that is slightly lower or higher.&lt;/p&gt;

&lt;p&gt;In addition, it may just be that the automatically selected value for t does not look good on your data. In this case you can pick t manually by gradually increasing t (e.g. starting at t=3) and visually inspect if the structure of the data is recovered but that it is not over-smoothed. For example, you can look at some known gene-gene relationships, or at the PCA after MAGIC. In addition, in the case that rare cell populations are present in the data, you can inspect whether these populations still exist after MAGIC and have not disappeared by being ‘pulled in’ by MAGIC. While the right t is data dependent, we have found that for almost all datasets the optimal t is between 3 and 12.&lt;/p&gt;

&lt;h3 id=&#34;cluster-mixing&#34;&gt;Cluster mixing&lt;/h3&gt;

&lt;p&gt;Another question that we often get is: “Does MAGIC contaminate cell types? Does it mix clusters or cell states/types that shouldn’t be mixed?” The answer is no, assuming that MAGIC is used correctly. The reason is that MAGIC learns the underlying nonlinear manifold of the data. This is something we will cover in more detail in future blog posts, but for now this means that the diffusion process follows the shape of the data. Diffusion doesn’t just mix each cell with every other cell, but it follows the biologically meaningful neighborhood structure of the data. This means that, effectively, the diffusion won’t leave a cluster or cell type/state and won’t mix cells that are biologically significantly different.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dburkhardt.github.io/2018-10-28-magic/clusters.png&#34; alt=&#34;Clusters&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In the above figure we ran MAGIC on a mouse cortex dataset (Zeisel et al. 2015). We’re showing the relationship between two genes and the colors correspond to the clusters reported by the authors. We can see that MAGIC preserves the clusters and does not mix them.&lt;/p&gt;

&lt;h3 id=&#34;cell-numbers&#34;&gt;Cell numbers&lt;/h3&gt;

&lt;p&gt;MAGIC requires a certain number of cells (data points) to work properly. Unfortunately we can’t give a specific number as this depends on the overall quality of the data, level of dropout and noise, and the underlying intrinsic dimensionality (effective degrees of freedom) of the data. In general, our experience is that at the very least we need 500 cells but more like 1000 for comfortable imputation. Moreover, the number of cells you have will determine the amount of detail that can be recovered. MAGIC may still work with 200 cells but would only recover one major trend in the data (e.g. a single progression). Including more cells enables recovery of more refined structures, e.g, additional branches or clusters.&lt;/p&gt;

&lt;h3 id=&#34;where-to-use-magic-in-your-pipeline&#34;&gt;Where to use MAGIC in your pipeline&lt;/h3&gt;

&lt;p&gt;MAGIC doesn’t just work on raw count matrices, fresh from your read mapping pipeline. MAGIC requires the data to be properly normalized and filtered. This preprocessing obviously depends on the data type and technology, but for single-cell RNA-seq data we have a set of preprocessing steps that work well and we recommend these to users of MAGIC. First, one has to make sure that “bad” cells are removed. For example, this can mean cells with small library size (total UMI). Next, the data has to be library size normalized, meaning that all values for a cell are divided by the total UMI in that cell. This prevents the neighborhoods from being dominated by cells of similar library size. Library size, generally, does not reflect biology since it is a result of the stochastic sampling of molecules. Next, we want to do a log type transform to the data. Popular is to take the natural log after adding a ‘pseudo’ count. The pseudo count enables taking log of zeros. A different, but similar, transform is the square root transform. This is what we often use. Like the log transform it effectively down weights highly expressed genes and high values, however it doesn’t require adding a pseudo count. After this filtering, normalization, and transform we can run MAGIC.&lt;/p&gt;

&lt;p&gt;In the below animations we show the effect of library size normalization. Notice how the trends in the two gifs are essentially opposite - the first gif shows MAGIC applied to raw counts data, where the variation is driven exclusively by UMI count, giving a misleading representation of the data. The second gif, after library size and log normalization, reflects a gene-gene relationship which matches our understanding of these genes from the literature.&lt;/p&gt;

&lt;h4 id=&#34;without-library-size-normalization&#34;&gt;Without library size normalization:&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://dburkhardt.github.io/2018-10-28-magic/no_norm_magic.gif&#34; alt=&#34;No normalization MAGIC&#34; /&gt;&lt;/p&gt;

&lt;h4 id=&#34;with-library-size-normalization&#34;&gt;With library size normalization:&lt;/h4&gt;

&lt;p&gt;&lt;img src=&#34;https://dburkhardt.github.io/2018-10-28-magic/norm_magic.gif&#34; alt=&#34;Normalization MAGIC&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;tutorials-and-help-running-magic&#34;&gt;Tutorials and help running MAGIC&lt;/h3&gt;

&lt;p&gt;We hope that with this post we have given you more insight into the workings of MAGIC and how to effectively use it. To learn how to use MAGIC we provide documentation and several tutorials in &lt;a href=&#34;https://github.com/KrishnaswamyLab/MAGIC&#34; title=&#34;MAGIC Github&#34; target=&#34;_blank&#34;&gt;our Github directory&lt;/a&gt;. Additionally, we have &lt;a href=&#34;https://krishnaswamylab-help.slack.com&#34; title=&#34;MAGIC Slack&#34; target=&#34;_blank&#34;&gt;a Slack group&lt;/a&gt; dedicated to helping users of our tools.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>1. What is single cell?</title>
      <link>https://dburkhardt.github.io/tutorial/what_is_single_cell/</link>
      <pubDate>Sun, 09 Sep 2018 00:00:00 -0400</pubDate>
      
      <guid>https://dburkhardt.github.io/tutorial/what_is_single_cell/</guid>
      <description>

&lt;p&gt;Recent advances in single cell proteomics and transcriptomics make it easier to collect single cell measurements across biological systems. The two most common methods are single cell RNA-sequencing and CyTOF. Although we will focus on scRNA-seq in this tutorial, the concepts important for single cell analysis generally hold across technologies. This is especially true for visualization, clustering, and differential expression.&lt;/p&gt;

&lt;h2 id=&#34;why-single-cell&#34;&gt;Why single cell?&lt;/h2&gt;

&lt;p&gt;Single cells are one of the basic units of biology. We generally think of single cells as the &lt;em&gt;things&lt;/em&gt; that act on themselves and surrounding extracellular structures to perform basic tasks such as moving appendages, processing external stimuli, defending the organism from infectious invaders, &lt;em&gt;etc.&lt;/em&gt;. Because these units are so important for the function of an organism, it&amp;rsquo;s naturally to wonder how many different kinds of cells are in a specific tissue, how these cells change over time, and how cells differ between individuals.&lt;/p&gt;

&lt;p&gt;Although the genome provides information for all these phenomena, it is the differences in expression of individual genes (at the DNA, RNA, and protein level) that account for differences in function across cell types. Because individual genes in individual cells effect functions in biological systems, one can understand why averaging expression across many cell types mixed at unknown ratios&amp;ndash;as done in bulk RNA-seq&amp;ndash;limits biological insight.&lt;/p&gt;

&lt;h2 id=&#34;a-brief-history-of-scrna-seq&#34;&gt;A brief history of scRNA-seq&lt;/h2&gt;

&lt;p&gt;Measuring gene expression in single cells has been around since at least 1992, when J. Eberwine &lt;em&gt;et al.&lt;/em&gt; published the first single cell qPCR assay in &lt;a href=&#34;https://doi.org/10.1073/pnas.89.7.3010&#34; target=&#34;_blank&#34;&gt;&lt;em&gt;Analysis of gene expression in single live neurons&lt;/em&gt; (1992)&lt;/a&gt;. They measured expression of roughly one dozen genes in 15 neurons isolated from the brain of a rat and characterized two distinct populations based on ion channel expression. Shortly thereafter in 1998, developments in smFISH (single molecule Fluorescence In Situ Hybridization) provided the a way to visualize expression of individual mRNA molecules in single cells &lt;a href=&#34;https://www.ncbi.nlm.nih.gov/pubmed/9554849&#34; target=&#34;_blank&#34;&gt;(Femino AM, et al. 1998)&lt;/a&gt;. smFISH remains the current gold standard for single cell RNA quantification and is used for validation of many scRNA-seq methods. In 2003, Kamme F &lt;em&gt;et al.&lt;/em&gt; expanded the set of genes assayable in single cells using microarrays &lt;a href=&#34;https://www.ncbi.nlm.nih.gov/pubmed/12736331&#34; target=&#34;_blank&#34;&gt;(Kamme F. &lt;em&gt;et al.&lt;/em&gt; 2003)&lt;/a&gt;. In that study, a groundbreaking ~4500 genes were assayed in 11 cells.&lt;/p&gt;

&lt;p&gt;All the above methods rely on some method of hybridization to nucleic acid probes. It wasn&amp;rsquo;t until 2009, however, when RNA sequencing expanded single cell RNA profiling to the entire transcriptome &lt;a href=&#34;https://www.ncbi.nlm.nih.gov/pubmed/19349980&#34; target=&#34;_blank&#34;&gt;(Tang, F. &lt;em&gt;et al.&lt;/em&gt; 2009)&lt;/a&gt;. This protocol and subsequent single cell protocols require the manual isolation of individual cells into PCR tubes for cDNA amplification. The time-consuming nature of this technique and high cost of preparing relatively large microliter-scale reverse transcription reactions kept dataset sizes down in the range of dozens of cells per sample. In 2012, Fluidigm introduced the C1 microfluidic device that (at the time) automatically captured up to 96 cells from a single cell suspension created single-cell libraries using nanoliter reaction volumes.&lt;/p&gt;

&lt;p&gt;The biggest disruption to single cell transcriptomics arrived in the summer of 2015 when two groups at Harvard published independent microfluidics technologies to capture cells in nanoliter droplets (&lt;a href=&#34;https://www.ncbi.nlm.nih.gov/pubmed/26000488&#34; target=&#34;_blank&#34;&gt;Macosko EZ. &lt;em&gt;et al.&lt;/em&gt; 2015&lt;/a&gt;; &lt;a href=&#34;https://www.ncbi.nlm.nih.gov/pubmed/26000487&#34; target=&#34;_blank&#34;&gt;Klein, AM. &lt;em&gt;et al.&lt;/em&gt; 2015&lt;/a&gt;). The speed, scalability, and low cost of these methods suddenly made it possible to profile tens of thousands of cells in a single experiment. These droplet single cell approaches were commercialized by 10X Genomics in 2016 in their $125k lunch-box sized Chromium device (&lt;a href=&#34;https://www.ncbi.nlm.nih.gov/pubmed/28091601&#34; target=&#34;_blank&#34;&gt;Zheng, GZ. &lt;em&gt;et al.&lt;/em&gt; 2017&lt;/a&gt;). Since then, there have been several advances in single cell transcriptomics, including the ability to capture simultaneously cell surface epitopes and transcriptomes in single cells (&lt;a href=&#34;https://www.ncbi.nlm.nih.gov/pubmed/28759029&#34; target=&#34;_blank&#34;&gt;Stoeckius M., &lt;em&gt;et al.&lt;/em&gt; 2017&lt;/a&gt;) and efficient split-pool library preparation methods (&lt;a href=&#34;https://www.ncbi.nlm.nih.gov/pubmed/28192419&#34; target=&#34;_blank&#34;&gt;Gierahn TM. &lt;em&gt;et al.&lt;/em&gt; 2017&lt;/a&gt;). However, most of the data our lab analyzes comes from the 10X Genomics 3&amp;rsquo; Single Cell library prep kit.&lt;/p&gt;

&lt;h2 id=&#34;how-to-capture-cells-in-droplets&#34;&gt;How to capture cells in droplets&lt;/h2&gt;

&lt;p&gt;Capturing mRNA from individual cells is a challenging goal. The first challenge is isoalting individual cells for reverse transcription. In droplet based methods this is done using a microfluidic chip. The following schematic from &lt;a href=&#34;https://www.ncbi.nlm.nih.gov/pubmed/28091601&#34; target=&#34;_blank&#34;&gt;Zheng, GZ. &lt;em&gt;et al.&lt;/em&gt; (2017)&lt;/a&gt; shows how this works.&lt;/p&gt;




&lt;figure class=&#34;img-md&#34;&gt;

&lt;img src=&#34;https://dburkhardt.github.io/img/how_to_single_cell/10x_cell_capture.png&#34; alt=&#34;*Image from [Zheng, GZ. et al. (2017)](https://www.ncbi.nlm.nih.gov/pubmed/28091601)*&#34; /&gt;



&lt;figcaption data-pre=&#34;Figure &#34; data-post=&#34;:&#34; &gt;
  
  &lt;p&gt;
    &lt;em&gt;Image from &lt;a href=&#34;https://www.ncbi.nlm.nih.gov/pubmed/28091601&#34; target=&#34;_blank&#34;&gt;Zheng, GZ. et al. (2017)&lt;/a&gt;&lt;/em&gt;
    
    
    
  &lt;/p&gt; 
&lt;/figcaption&gt;

&lt;/figure&gt;

&lt;p&gt;The chip captures beads loaded with barcoded library adapters and individual cells into droplets. These droplets form an emulsion because they are suspended in oil. In the next image, you can see a single looped cell capture event on a DropSeq chip.&lt;/p&gt;




&lt;figure class=&#34;img-md&#34;&gt;

&lt;img src=&#34;https://dburkhardt.github.io/img/how_to_single_cell/dropseq_capture.gif&#34; alt=&#34;*Image from [dropseq.org](https://www.dropseq.org)*&#34; /&gt;



&lt;figcaption data-pre=&#34;Figure &#34; data-post=&#34;:&#34; &gt;
  
  &lt;p&gt;
    &lt;em&gt;Image from &lt;a href=&#34;https://www.dropseq.org&#34; target=&#34;_blank&#34;&gt;dropseq.org&lt;/a&gt;&lt;/em&gt;
    
    
    
  &lt;/p&gt; 
&lt;/figcaption&gt;

&lt;/figure&gt;

&lt;p&gt;Here, a single cell (bottom) joins a bead in lysis buffer (left) as they flow through the chip. Oil flows in through the channels in the middle and pinch off individual droplets.&lt;/p&gt;

&lt;p&gt;Although the exact nature of the bead varies between technologies, the basic idea is that each bead contains uniquely-barcoded adapters with: an oligo d(T) that hybridizes to poly-A tails, a cell barcode, a unique molecular identifier, and reverse transcription primers.&lt;/p&gt;

&lt;h2 id=&#34;scrna-seq-library-preparation&#34;&gt;scRNA-seq library preparation&lt;/h2&gt;

&lt;p&gt;Although you probably know this, let&amp;rsquo;s start by reviewing the basic structure of an mRNA.&lt;/p&gt;




&lt;figure class=&#34;img-md&#34;&gt;

&lt;img src=&#34;https://dburkhardt.github.io/img/how_to_single_cell/gene_model.jpg&#34; alt=&#34;*Image from [APASdb](http://genome.bucm.edu.cn/utr/)*&#34; /&gt;



&lt;figcaption data-pre=&#34;Figure &#34; data-post=&#34;:&#34; &gt;
  
  &lt;p&gt;
    &lt;em&gt;Image from &lt;a href=&#34;http://genome.bucm.edu.cn/utr/&#34; target=&#34;_blank&#34;&gt;APASdb&lt;/a&gt;&lt;/em&gt;
    
    
    
  &lt;/p&gt; 
&lt;/figcaption&gt;

&lt;/figure&gt;

&lt;p&gt;In the standard 3&amp;rsquo; library preparation, the goal is to select for mRNA using the polyA tail. Selection is necessary because the majority of RNA in a cell consists of ribosomal RNA (rRNA) and transfer RNA (tRNA). We don&amp;rsquo;t want to sequence these functional RNAs because they don&amp;rsquo;t give us information about gene expression. To select poly-adenylated mRNA, the library adapters include a long stretch of thymines (Ts) that hybridize with the long stretch of adenines (As) in the polyA tail.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.ncbi.nlm.nih.gov/pubmed/30089906&#34; target=&#34;_blank&#34;&gt;La Manno, G. &lt;em&gt;et al.&lt;/em&gt; (2018)&lt;/a&gt; found that these library adapters also prime internally (&lt;em&gt;i.e.&lt;/em&gt; more 5&amp;rsquo; than the polyA) making it possible to sequence the introns of newly-transcribed pre-mRNA molecules facilitating the detection of actively expressed genes.&lt;/p&gt;

&lt;p&gt;Following hybridization of adapters, the basic steps for library preparation are as follows:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Cell is captured in droplet with bead&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Cell lyses in hypotonic buffer within droplet&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;3&amp;rsquo; barcoded-adapter hybridizes to polyA tails on mRNA&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;First strand reverse transcription (RT)&lt;/li&gt;
&lt;li&gt;Second strand RT&lt;/li&gt;
&lt;li&gt;PCR amplification&lt;/li&gt;
&lt;li&gt;Fractionation and size selection&lt;/li&gt;
&lt;li&gt;5&amp;rsquo; adapter ligation&lt;/li&gt;
&lt;li&gt;Final amplification&lt;/li&gt;
&lt;li&gt;Sequencing&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;p&gt;The exact library preparation protocol will vary by technology (and version thereof). For a detailed explanation of the library preparation, consult technical documentation for whichever technology you&amp;rsquo;ll use.&lt;/p&gt;

&lt;/div&gt;


&lt;p&gt;Because of the size selection and PCR amplification primed using the 3&amp;rsquo; and 5&amp;rsquo; adapters, the library is heavily 3&amp;rsquo; biased with the majority of the read coverage falling ~200nt from the 3&amp;rsquo; untranslated region (UTR) of the mRNA. Note, however, that annotated 3&amp;rsquo; UTRs do not always correspond to the actual isoform expressed in a sample. For this reason, you may get coverage &amp;ldquo;past&amp;rdquo; the end of the gene.&lt;/p&gt;

&lt;p&gt;In the following plot, I took the 9K PBMC dataset from 10X Genomics and plotted coverage over the top 500 expressed genes relative to the annotated 3&amp;rsquo; UTR.&lt;/p&gt;




&lt;figure class=&#34;img-md&#34;&gt;

&lt;img src=&#34;https://dburkhardt.github.io/img/how_to_single_cell/coverage_over_utr3.png&#34; /&gt;


&lt;/figure&gt;

&lt;h2 id=&#34;special-considerations-for-single-cell-data&#34;&gt;Special considerations for single cell data&lt;/h2&gt;

&lt;p&gt;Single cell datasets are unlike most other biological datasets for several reasons. First, these datasets are &lt;em&gt;large&lt;/em&gt;. When analyzing bulk RNA-seq data, it is common to have roughly 2 to 10 datasets. A massive dataset, like the one generated by the  GTEx (Genotype-Tissue Expression) consortium, might have 50,000 gene expression measurements. Compare this to the 1.3 million cells dataset generated by 10X Genomics in 2017. Even a lab with no experience generating large biomedical data can use scRNA-seq to measure gene expression in several thousand cells. The sheer number of observations in these datasets necessitate special computational approaches to analyze them.&lt;/p&gt;

&lt;p&gt;Another reason that single cell datasets are challenging to analyze is they are &lt;em&gt;high dimensional&lt;/em&gt;. Compared to more common single cell methods like FACS or single cell qPCR or microarrays, scRNA-seq datasets comprise many more features per cell. This makes it difficult to understand things like &amp;ldquo;which cells are close to which?&amp;rdquo; or &amp;ldquo;what genes are most similar?&amp;rdquo;. Thankfully, we can make some simplifying assumptions that make tackling these questions easier.&lt;/p&gt;

&lt;p&gt;Single cell data is also &lt;em&gt;noisy&lt;/em&gt;. In scRNA-seq, it is estimated that only 10-40% of the hundreds of thousands of genes in a cell are captured during reverse transcription.&lt;/p&gt;

&lt;h2 id=&#34;common-goals-for-analysis-of-scrna-seq-data&#34;&gt;Common goals for analysis of scRNA-seq data&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>1. Preprocessing</title>
      <link>https://dburkhardt.github.io/tutorial/preprocessing/</link>
      <pubDate>Sun, 09 Sep 2018 00:00:00 -0400</pubDate>
      
      <guid>https://dburkhardt.github.io/tutorial/preprocessing/</guid>
      <description>

&lt;h2 id=&#34;1-0-introducing-scprep&#34;&gt;1.0 Introducing &lt;code&gt;scprep&lt;/code&gt;&lt;/h2&gt;

&lt;h4 id=&#34;scprep-is-a-lightweight-scrna-seq-toolkit-for-python-data-scientists&#34;&gt;Scprep is a lightweight scRNA-seq toolkit for Python Data Scientists&lt;/h4&gt;

&lt;p&gt;Most scRNA-seq toolkits are written in R, but we develop our tools in Python. Currently, &lt;a href=&#34;https://github.com/theislab/scanpy&#34; target=&#34;_blank&#34;&gt;Scanpy&lt;/a&gt; is the most popular toolkit for scRNA-seq analysis in Python. In fact, if you&amp;rsquo;d prefer to use that, you can find most of our lab&amp;rsquo;s analytical methods including PHATE and MAGIC in scanpy. However, scanpy has a  highly structured framework for data representation and a steep learning curve that is unnescessary for users already comfortable with the suite of methods available in &lt;a href=&#34;https://pandas.pydata.org/&#34; target=&#34;_blank&#34;&gt;Pandas&lt;/a&gt;, &lt;a href=&#34;https://www.scipy.org/&#34; target=&#34;_blank&#34;&gt;Scipy&lt;/a&gt;, and &lt;a href=&#34;http://scikit-learn.org/stable/&#34; target=&#34;_blank&#34;&gt;Sklearn&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To accomodate these users (including ourselves) we developed &lt;code&gt;scprep&lt;/code&gt; (Single Cell PREParation). &lt;code&gt;scprep&lt;/code&gt; makes it easier to use the Pandas / Scipy / Sklearn ecosystem for scRNA-seq analysis. Most of &lt;code&gt;scprep&lt;/code&gt; is composed of helper functions to perform tasks common to single cell data like loading counts matrices, filtering &amp;amp; normalizing cells by library size, and calculating common statistics. The key advantage of scprep is that data can be stored in Pandas DataFrames, Numpy arrays, Scipy Sparse Matices, it is &lt;em&gt;just works&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;For users starting out, you might find it more valuable to spend time spent getting comfortable with these tools because they can be used for analysis of all kinds of data, not just scRNA-seq. If you want to learn more, checkout the &lt;a href=&#34;https://docs.scipy.org/doc/numpy-1.15.1/user/quickstart.html&#34; target=&#34;_blank&#34;&gt;Numpy Quickstart Tutorial&lt;/a&gt;, the &lt;a href=&#34;https://pandas.pydata.org/pandas-docs/stable/tutorials.html&#34; target=&#34;_blank&#34;&gt;Pandas Tutorials&lt;/a&gt;, the &lt;a href=&#34;https://matplotlib.org/tutorials/index.html&#34; target=&#34;_blank&#34;&gt;Matplotlib Tutorials&lt;/a&gt;, and consider getting a copy of Wes McKinney&amp;rsquo;s book &lt;a href=&#34;http://shop.oreilly.com/product/0636920050896.do&#34; target=&#34;_blank&#34;&gt;Python for Data Analysis&lt;/a&gt;. McKinney is the original author of Pandas, and I&amp;rsquo;m glad I went through the book at the beginning of my PhD.&lt;/p&gt;

&lt;h3 id=&#34;installation&#34;&gt;Installation&lt;/h3&gt;

&lt;p&gt;From here on out, I will assume that you have Python, Numpy, Pandas, Scipy, Scikit-learn, and Matplotlib all installed.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;scprep&lt;/code&gt; package is available on &lt;a href=&#34;https://github.com/krishnaswamylab/scprep&#34; target=&#34;_blank&#34;&gt;GitHub&lt;/a&gt; and on &lt;a href=&#34;https://pypi.org/project/scprep/&#34; target=&#34;_blank&#34;&gt;PyPI&lt;/a&gt; so the install is straightforward:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;$ pip install --user scprep&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;In &lt;code&gt;scprep&lt;/code&gt; you&amp;rsquo;ll find tools for loading single cell data (&lt;code&gt;scprep.io&lt;/code&gt;), library size normalization (&lt;code&gt;scprep.normalize&lt;/code&gt;), transforming data (&lt;code&gt;scprep.transform&lt;/code&gt;), performing statistical calculations (&lt;code&gt;scprep.stats&lt;/code&gt;), and many others. Check out &lt;a href=&#34;https://scprep.readthedocs.io/&#34; target=&#34;_blank&#34;&gt;the screp documentation&lt;/a&gt; for the full API.&lt;/p&gt;

&lt;h2 id=&#34;1-1-using-scprep-to-load-a-10x-genomics-counts-matrix&#34;&gt;1.1 - Using scprep to load a 10X Genomics counts matrix&lt;/h2&gt;

&lt;p&gt;Most of the labs we work with use 10X Genomics for single cell sequencing, so we&amp;rsquo;ll use this as an example.&lt;/p&gt;

&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;p&gt;&lt;code&gt;scprep.io&lt;/code&gt; also has helper functions for csv, tsv, and mtx files.&lt;/p&gt;

&lt;/div&gt;


&lt;p&gt;Say your 10X data is in &lt;code&gt;/home/user/data/my_sample&lt;/code&gt;. To load your data, run:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; scprep
data_uf &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; scprep&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;io&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;load_10X(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;/home/user/data/my_sample/outs/filtered_gene_bc_matrices/my_genome/&amp;#39;&lt;/span&gt;, sparse&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;True, gene_labels&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;both&amp;#39;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Here, &lt;code&gt;data_uf&lt;/code&gt; is my shorthand for &amp;lsquo;data_unfiltered&amp;rsquo;. &lt;code&gt;load_10X&lt;/code&gt; and other &lt;code&gt;scprep.io&lt;/code&gt; functions return a &lt;a href=&#34;https://pandas.pydata.org/pandas-docs/stable/sparse.html&#34; target=&#34;_blank&#34;&gt;Pandas &lt;code&gt;SparseDataFrame&lt;/code&gt;&lt;/a&gt; by default. The &lt;code&gt;SparseDataFrame&lt;/code&gt; behaves similarly to regular Pandas &lt;code&gt;DataFrames&lt;/code&gt;, but take up much less memory by storing only non-zero values and their indices in memory. Note: operations are sparse matrices are slower than dense matrices. If you can afford to store the dense matrix in memory, set &lt;code&gt;sparse=False&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;As an aside, many genome annotations (the descriptions of where genes are located on a given genome) contain non-unique gene symbols, so with &lt;code&gt;gene_labels=both&lt;/code&gt; we store the gene symbol and the gene ID as &lt;code&gt;&#39;ACTB (ENSG00000075624)&#39;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If you look at the head of your data, you should see something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;data_uf.head()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[sparse_dataframe_head.png]&lt;/p&gt;

&lt;p&gt;Now, let&amp;rsquo;s start preprocessing your data.&lt;/p&gt;

&lt;h2 id=&#34;1-2-merging-batches-using-scprep-optional&#34;&gt;1.2 -  Merging batches using &lt;code&gt;scprep&lt;/code&gt; (optional)&lt;/h2&gt;

&lt;p&gt;This is the point to merge batches if you have multiple samples from the sample experiment that you want to compare. Although we&amp;rsquo;ll talk briefly about batch effects later, we&amp;rsquo;ll write a whole post about how to correct them at another point.&lt;/p&gt;

&lt;h4 id=&#34;how-to-combine-samples&#34;&gt;How to combine samples&lt;/h4&gt;

&lt;p&gt;Here, what we&amp;rsquo;re doing is taking counts matrices from each sample and stacking them vertically. We&amp;rsquo;ve implemented this in the &lt;a href=&#34;https://scprep.readthedocs.io/en/stable/reference.html#scprep.utils.combine_batches&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;scprep.utils.combine_batches&lt;/code&gt;&lt;/a&gt; function.&lt;/p&gt;

&lt;p&gt;For this example, I&amp;rsquo;m going to use the Embryoid Body timecourse covered in the &lt;a href=&#34;http://nbviewer.jupyter.org/github/KrishnaswamyLab/PHATE/blob/master/Python/tutorial/EmbryoidBody.ipynb&#34; target=&#34;_blank&#34;&gt;PHATE tutorial&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Two important notes:&lt;/p&gt;

&lt;p&gt;First, it&amp;rsquo;s important to know exactly which rows of the data matrix correspond to which sample so that we can separate them during downstream analysis. To facilitate this, &lt;code&gt;combine_batches()&lt;/code&gt; takes an list &lt;code&gt;batch_labels&lt;/code&gt; that contains one label per sample and returns an array &lt;code&gt;sample labels&lt;/code&gt; that contains the sample label for each row in the resulting matrix.&lt;/p&gt;

&lt;p&gt;Second, it&amp;rsquo;s possible (and exceedingly common) for the same cell barcode to appear in multiple experiments. This becomes an issue when combining batches because you want each row to have a unique index. To solve this problem, we append the sample label to the cell barcode by setting &lt;code&gt;append_to_cell_names=True&lt;/code&gt;. This turns cell barcode &lt;code&gt;AAACATACCAGAGG-1&lt;/code&gt; from  sample &lt;code&gt;Day0-3&lt;/code&gt; to &lt;code&gt;AAACATACCAGAGG-1_Day0-3&lt;/code&gt;&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# Loading each of 5 timepoints&lt;/span&gt;
T1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; scprep&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;io&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;load_10X(os&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;path&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;join(download_path, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;scRNAseq&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;T0_1A&amp;#34;&lt;/span&gt;), gene_labels&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;both&amp;#39;&lt;/span&gt;)
T2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; scprep&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;io&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;load_10X(os&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;path&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;join(download_path, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;scRNAseq&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;T2_3B&amp;#34;&lt;/span&gt;), gene_labels&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;both&amp;#39;&lt;/span&gt;)
T3 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; scprep&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;io&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;load_10X(os&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;path&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;join(download_path, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;scRNAseq&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;T4_5C&amp;#34;&lt;/span&gt;), gene_labels&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;both&amp;#39;&lt;/span&gt;)
T4 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; scprep&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;io&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;load_10X(os&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;path&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;join(download_path, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;scRNAseq&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;T6_7D&amp;#34;&lt;/span&gt;), gene_labels&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;both&amp;#39;&lt;/span&gt;)
T5 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; scprep&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;io&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;load_10X(os&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;path&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;join(download_path, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;scRNAseq&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;T8_9E&amp;#34;&lt;/span&gt;), gene_labels&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;both&amp;#39;&lt;/span&gt;)

&lt;span style=&#34;color:#75715e&#34;&gt;# Concatenating data matrices&lt;/span&gt;
EBT_counts, sample_labels &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; scprep&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;utils&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;combine_batches(
    data&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;[T1, T2, T3, T4, T5],
    batch_labels&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;[&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Day0-3&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Day6-9&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Day12-15&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Day18-21&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Day24-27&amp;#34;&lt;/span&gt;],
    append_to_cell_names&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;True
)

&lt;span style=&#34;color:#75715e&#34;&gt;# remove objects from memory&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;del&lt;/span&gt; T1, T2, T3, T4, T5  &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;p&gt;It&amp;rsquo;s good practice to remove the original data matrices from memory and avoid doubling the memory usage of our scripts.&lt;/p&gt;

&lt;/div&gt;


&lt;h2 id=&#34;1-3-filtering-cells-by-library-size&#34;&gt;1.3 -  Filtering cells by library size&lt;/h2&gt;

&lt;h4 id=&#34;why-we-filter-cells-by-library-size&#34;&gt;Why we filter cells by library size&lt;/h4&gt;

&lt;p&gt;In scRNA-seq the library size of a cell is the number of unique mRNA molecules detected in that cell. These unique molecules are identified using a random barcode incorporated during the first round of reverse transcription. This barcode is called a &lt;strong&gt;U&lt;/strong&gt;nique &lt;strong&gt;M&lt;/strong&gt;olecule &lt;strong&gt;I&lt;/strong&gt;ndicator, and often we refer to the number unique mRNAs in a cell as the number of UMIs. To read more about UMIs, &lt;a href=&#34;https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5340976/&#34; target=&#34;_blank&#34;&gt;Smith &lt;em&gt;et al.&lt;/em&gt; (2017)&lt;/a&gt; write about how sequencing errors and PCR amplification errors lead to innaccurate quantification of UMIs/cell.&lt;/p&gt;

&lt;p&gt;Depending on the method of scRNA-seq, the amount of library size filtering done can vary. The 10X Genomics CellRanger tool, the DropSeq and InDrops pipelines, and the Umitools package each have their own method and cutoff for determining real cells from empty droplets. You can take these methods at face value or set some manual cutoffs based on your data.&lt;/p&gt;

&lt;h4 id=&#34;visualing-the-library-size-distribution-using-scprep&#34;&gt;Visualing the library size distribution using &lt;code&gt;scprep&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;There is a helper function for plotting library size from a gene expression matrix in scprep called &lt;a href=&#34;https://scprep.readthedocs.io/en/stable/reference.html#scprep.plot.plot_library_size&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;scprep.plot.plot_library_size()&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Here we can see a typical library size for a 10X dataset from &lt;a href=&#34;https://www.ncbi.nlm.nih.gov/pubmed/?term=28099430&#34; target=&#34;_blank&#34;&gt;Datlinger &lt;em&gt;et al.&lt;/em&gt; (2017)&lt;/a&gt;. In this sample we see that there is a long tail of cells that have very high library sizes.&lt;/p&gt;




&lt;figure class=&#34;img-md&#34;&gt;

&lt;img src=&#34;https://dburkhardt.github.io/img/how_to_single_cell/libsize_example_normal.png&#34; /&gt;


&lt;/figure&gt;

&lt;h4 id=&#34;selecting-a-cutoff&#34;&gt;Selecting a cutoff&lt;/h4&gt;

&lt;p&gt;Several papers describe strategies for picking a maximum and minimum threshold that can be found with a quick google search for &amp;ldquo;library size threshold single cell RNA seq&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Most of these pick an arbitrary measure such as a certain number of deviations below or above the mean or median library size. We find that spending too much time worrying about the exact threshold is inefficient.&lt;/p&gt;

&lt;p&gt;For the above dataset, I would remove all cells with more than 25,000 UMI / cell in fear they might represent doublets of cells. I will generally also remove all cells with fewer than 500 reads per cell.&lt;/p&gt;

&lt;h4 id=&#34;filtering-cells-by-library-size&#34;&gt;Filtering cells by library size&lt;/h4&gt;

&lt;p&gt;You can do this using &lt;a href=&#34;https://scprep.readthedocs.io/en/stable/reference.html#scprep.filter.filter_library_size&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;scprep.filter.filter_library_size()&lt;/code&gt;&lt;/a&gt;. The syntax looks like:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;data &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; scprep&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;filter&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;filter_library_size(data_uf, cutoff&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;25000&lt;/span&gt;, keep_cells&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;below&amp;#39;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;And now when we plot the library size we see:&lt;/p&gt;




&lt;figure class=&#34;img-md&#34;&gt;

&lt;img src=&#34;https://dburkhardt.github.io/img/how_to_single_cell/libsize_example_filtered.png&#34; /&gt;


&lt;/figure&gt;

&lt;p&gt;Note that there are many different valid distributions of library sizes. See the following three libraries, all generated from different tissues in the zebrafish embryo. One of the libraries is from a failed experiment, and the other two are from published papers.&lt;/p&gt;

&lt;p&gt;Can you tell which is which?&lt;/p&gt;




&lt;figure class=&#34;img-md&#34;&gt;

&lt;img src=&#34;https://dburkhardt.github.io/img/how_to_single_cell/libsize_comparison.png&#34; /&gt;


&lt;/figure&gt;

&lt;p&gt;Here, Sample 1 is from &lt;a href=&#34;https://www.ncbi.nlm.nih.gov/pubmed/29576475&#34; target=&#34;_blank&#34;&gt;Pandley &lt;em&gt;et al.&lt;/em&gt; (2018)&lt;/a&gt;, Sample 2 is an internal failed experiment, and Sample 3 is from &lt;a href=&#34;https://www.ncbi.nlm.nih.gov/pubmed/29700225&#34; target=&#34;_blank&#34;&gt;Farrell &lt;em&gt;et al.&lt;/em&gt; (2018)&lt;/a&gt;. The low library size in Sample 2 is the giveaway with 90% of cells having fewer than 1200 UMI/cell and a mode at 325 UMI/cell. Additionally, this library generated a &lt;strong&gt;Low Fraction Reads in Cells&lt;/strong&gt; alert in the Cell Ranger web summary with only 33% of reads assigned to cells. To learn more about what this means, &lt;a href=&#34;https://community.10xgenomics.com/t5/Single-Cell-Forum/Reason-s-for-low-quot-Fraction-Reads-in-Cell-quot/td-p/5273&#34; target=&#34;_blank&#34;&gt;read this post in the 10X Forums.&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;1-4-filtering-lowly-expressed-genes&#34;&gt;1.4 - Filtering lowly expressed genes&lt;/h2&gt;

&lt;h4 id=&#34;why-remove-lowly-expressed-genes&#34;&gt;Why remove lowly expressed genes?&lt;/h4&gt;

&lt;p&gt;Capturing RNA from single cells is a noisy process. The first round of reverse transcription is done in the presence of cell lysate. This results in capture of only 10-40% of the mRNA molecules in a cell leading to a phenomenon called dropout where some lowly expressed genes are not detected in cells in which they are expressed [&lt;a href=&#34;https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5561556/#CR13&#34; target=&#34;_blank&#34;&gt;1&lt;/a&gt;, &lt;a href=&#34;https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5561556/#CR44&#34; target=&#34;_blank&#34;&gt;2&lt;/a&gt;, &lt;a href=&#34;https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5561556/#CR64&#34; target=&#34;_blank&#34;&gt;3&lt;/a&gt;, &lt;a href=&#34;https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5561556/#CR65&#34; target=&#34;_blank&#34;&gt;4&lt;/a&gt;]. As a result, some genes are so lowly expressed (or expressed not at all) that we do not have sufficient observations of that gene to make any inferences on its expression.&lt;/p&gt;

&lt;p&gt;Lowly expressed genes that may only be represented by a handful of mRNAs may not appear in a given dataset. Others might only be present in a small number of cells. Because we lack sufficient information about these genes, we remove lowly expressed genes from the gene expression matrix during preprocessing. Typically, if a gene is detected in fewer than 5 or 10 cells, it gets removed.&lt;/p&gt;

&lt;p&gt;Here, we can see that in the T cell dataset from Datlinger et al. (2017), there are many genes that are detected in very few cells.&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;genes_per_cell &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;sum(t_cell_data &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, axis&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)

fig, ax &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; plt&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;subplots(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, figsize&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;))
ax&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;hist(genes_per_cell, bins&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;)
ax&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;set_xlabel(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;# cells in which gene is expressed&amp;#39;&lt;/span&gt;)
ax&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;set_ylabel(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;# of genes&amp;#39;&lt;/span&gt;)
ax&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;set_yscale(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;symlog&amp;#39;&lt;/span&gt;)
ax&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;set_title(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Gene detection across cells&amp;#39;&lt;/span&gt;)
fig&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;tight_layout()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;




&lt;figure class=&#34;img-md&#34;&gt;

&lt;img src=&#34;https://dburkhardt.github.io/img/how_to_single_cell/gene_detection.png&#34; /&gt;


&lt;/figure&gt;

&lt;p&gt;Here, around 16,000/35,000 genes are detected in fewer than 10 cells. We can remove these columns from the gene expression matrix moving forward.&lt;/p&gt;

&lt;h4 id=&#34;how-to-remove-lowly-expressed-genes-using-scprep&#34;&gt;How to remove lowly expressed genes using &lt;code&gt;scprep&lt;/code&gt;.&lt;/h4&gt;

&lt;p&gt;The syntax to remove these genes is similar to filtering on library size. The scprep function is &lt;a href=&#34;https://scprep.readthedocs.io/en/stable/reference.html#scprep.filter.remove_rare_genes&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;scprep.filter.remove_rare_genes()&lt;/code&gt;&lt;/a&gt;. You can use it like this:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;data &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; scprep&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;filter&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;remove_rare_genes(data, cutoff&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, min_cells&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Another advantage of removing rare genes from our counts matrix is that it reduces the dimensions of the matrix that we&amp;rsquo;re working with. Instead of needing to do computations over a matrix that is 10,000x35,000, we are now working with one that is 10,000x16,000.&lt;/p&gt;

&lt;h2 id=&#34;1-5-library-size-normalization&#34;&gt;1.5 -  Library size normalization&lt;/h2&gt;

&lt;h4 id=&#34;why-library-size-normalize&#34;&gt;Why library size normalize?&lt;/h4&gt;

&lt;p&gt;Now that we have our cells filtered by library size and have removed lowly expressed genes from our dataset, it&amp;rsquo;s time to normalize the data. Library size normalization is meant to align the scales of gene expression across cells that have different # of UMIs / cell. This is equivalent to comparing only the ratios of genes detected within a cell as opposed to comparing the absolute quantity of each RNA.&lt;/p&gt;

&lt;p&gt;Mathematically, this process involves diving the count of each gene in each cell by the # UMIs in that cell. Optionally, one may then multiply the gene expression in all cells by a constant, such as the median # UMIs /cell in an experiment. This is purely a stylistic choice, but makes interpreting gene expression values a little easier.&lt;/p&gt;

&lt;h4 id=&#34;normalizing-library-size-using-scprep&#34;&gt;Normalizing library size using &lt;code&gt;scprep&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;This step is accomplished using the &lt;a href=&#34;https://scprep.readthedocs.io/en/stable/reference.html#scprep.normalize.library_size_normalize&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;scprep.normalize.library_size_normalize()&lt;/code&gt;&lt;/a&gt; function with the following syntax:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;data_ln &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; scprep&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;normalize&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;library_size_normalize(data)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Here, I use &lt;code&gt;data_ln&lt;/code&gt; to refer to &lt;strong&gt;data&lt;/strong&gt; that has been &lt;strong&gt;l&lt;/strong&gt;ibrary size &lt;strong&gt;n&lt;/strong&gt;ormalized.&lt;/p&gt;

&lt;h2 id=&#34;1-6-removing-cells-with-high-mitochondrial-gene-expression&#34;&gt;1.6 - Removing cells with high mitochondrial gene expression&lt;/h2&gt;

&lt;h4 id=&#34;what-does-high-mitochondrial-gene-expression-indicate&#34;&gt;What does high mitochondrial gene expression indicate?&lt;/h4&gt;

&lt;p&gt;Generally, we assume that cells with high detection of mitochondrial RNAs have undergone degradation of the mitochondrial membrane as a result of apoptosis. This may be from stress during dissociation, culture, or really anywhere in the experimental pipeline. As with the high and low library size cells, we want to remove the long tail from the distribution. In a successful experiment, it&amp;rsquo;s typical for 5-10% of the cells to have this apoptotic signature.&lt;/p&gt;

&lt;h4 id=&#34;plotting-mitochondrial-expression&#34;&gt;Plotting mitochondrial expression&lt;/h4&gt;

&lt;p&gt;Let&amp;rsquo;s look at the mitochondrial expression from Datlinger &lt;em&gt;et al.&lt;/em&gt; (2017). Here, the dashed line is the 95th percentile of mitochondrial expression.&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# get mitochondrial genes&lt;/span&gt;
mitochondrial_gene_list &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; np&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;array([g&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;startswith(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;MT-&amp;#39;&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; g &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; data_ln&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;columns])

&lt;span style=&#34;color:#75715e&#34;&gt;# get expression&lt;/span&gt;
mito_exp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; data_ln&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;loc[:,mitochondrial_gene_list]&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;mean(axis&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)

&lt;span style=&#34;color:#75715e&#34;&gt;# plotting&lt;/span&gt;
fig, ax &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; plt&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;subplots(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, figsize&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;))

ax&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;hist(mito_exp, bins&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;100&lt;/span&gt;)
ax&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;axvline(np&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;percentile(mito_exp, &lt;span style=&#34;color:#ae81ff&#34;&gt;95&lt;/span&gt;))
ax&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;set_xlabel(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Mean mitochondrial expression&amp;#39;&lt;/span&gt;)
ax&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;set_ylabel(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;# of cells&amp;#39;&lt;/span&gt;)
ax&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;set_title(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;Mitochondrial expression&amp;#39;&lt;/span&gt;)

fig&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;tight_layout()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;




&lt;figure class=&#34;img-md&#34;&gt;

&lt;img src=&#34;https://dburkhardt.github.io/img/how_to_single_cell/mito_expression.png&#34; /&gt;


&lt;/figure&gt;

&lt;h4 id=&#34;removing-cells-with-high-mitochondrial-expression-using-scprep&#34;&gt;Removing cells with high mitochondrial expression using &lt;code&gt;scprep&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;Each genome and species will have its own list of mitochondrial genes and associated symbols. In human and mouse, these genes start with &amp;lsquo;MT-&amp;rsquo;. However, as there&amp;rsquo;s no standard, we didn&amp;rsquo;t want to include a function for filtering mitochondrial expression directly in &lt;code&gt;scprep&lt;/code&gt;. Instead, we provide the &lt;a href=&#34;https://scprep.readthedocs.io/en/stable/reference.html#scprep.filter.filter_values&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;scprep.filter.filter_values()&lt;/code&gt;&lt;/a&gt; function. This method takes &lt;code&gt;data&lt;/code&gt; and an array &lt;code&gt;values&lt;/code&gt; and removes all cells from &lt;code&gt;data&lt;/code&gt; where &lt;code&gt;values&lt;/code&gt; is above or below the set &lt;code&gt;threshold&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Here, this would look like:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# filter cells above 95th percentile&lt;/span&gt;
data_ln &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; scprep&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;filter&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;filter_values(data_ln, mito_expression, percentile&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;95&lt;/span&gt;, keep_cells&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;below&amp;#39;&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&#34;1-7-transforming-data&#34;&gt;1.7 - Transforming data&lt;/h2&gt;

&lt;p&gt;Our final step for preprocessing is to transform the data so that it&amp;rsquo;s usable for the algorithms that we&amp;rsquo;re using later.&lt;/p&gt;

&lt;p&gt;The purpose of transforming data is to make sure that each gene or feature in our counts matrix is counted equally. Because of math, if we&amp;rsquo;re doing something like calculating the &lt;a href=&#34;https://en.wikipedia.org/wiki/Euclidean_distance&#34; target=&#34;_blank&#34;&gt;Euclidean distance&lt;/a&gt; between two cells, genes that are more highly expressed (&lt;em&gt;i.e.&lt;/em&gt; have larger values) will be considered more important.&lt;/p&gt;

&lt;p&gt;There are many transforms, but the two most common for scRNA-seq are the log-transform and the square-root transform. In CyTOF, the arcsinh transform is also popular. You can access all of these using &lt;a href=&#34;https://scprep.readthedocs.io/en/stable/reference.html#scprep.transform.log&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;scprep.transform.log()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&#34;https://scprep.readthedocs.io/en/stable/reference.html#scprep.transform.log&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;scprep.transform.sqrt()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&#34;https://scprep.readthedocs.io/en/stable/reference.html#scprep.transform.arcsinh&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;scprep.transform.arcsinh()&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;One note: the log-transform doesn&amp;rsquo;t like zeros, which are incredibly common in single cell datasets. To overcome this, people commonly add a pseudocount to their data, either 1 or a very small value called &lt;a href=&#34;https://en.wikipedia.org/wiki/Machine_epsilon&#34; target=&#34;_blank&#34;&gt;machine epsilon&lt;/a&gt;. Personally, I don&amp;rsquo;t like this because it skews the relationships between small values, which are a huge portion of single cell counts matrices.&lt;/p&gt;

&lt;p&gt;Instead, we use the squareroot transform 99% of the time. The syntax couldn&amp;rsquo;t be simpler:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;data_sq &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; scprep&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;transform&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;sqrt(data_ln)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h4 id=&#34;we-re-done-preprocessing&#34;&gt;We&amp;rsquo;re done preprocessing!&lt;/h4&gt;

&lt;p&gt;Congratulations, we&amp;rsquo;re ready to start visualizing!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>2. Visualizing PCA dimensions</title>
      <link>https://dburkhardt.github.io/tutorial/visualizing_pca/</link>
      <pubDate>Sun, 09 Sep 2018 00:00:00 -0400</pubDate>
      
      <guid>https://dburkhardt.github.io/tutorial/visualizing_pca/</guid>
      <description>

&lt;p&gt;In this section, we&amp;rsquo;re going to go over a few introductory techniques for visualizing and exploring a single cell dataset. This is an essential analysis step, and will tell us a lot about the nature of the data we&amp;rsquo;re working with. We&amp;rsquo;ll figure out things like:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If the data exists on a trajectory, clusters, or a mix of both&lt;/li&gt;
&lt;li&gt;How many kinds of cells are likely present in a dataset&lt;/li&gt;
&lt;li&gt;If there are batch effects between samples&lt;/li&gt;
&lt;li&gt;If there are technical artifacts remaining after preprocessing&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We&amp;rsquo;re going to use two main tools for this analysis: PCA and PHATE. PCA is useful because it&amp;rsquo;s quick and serves as a preliminary readout of what&amp;rsquo;s going on in a sample. However, PCA has many limitations as a visualization method because it can only recover linear combinations of genes. To get a better sense of the underlying structure of our dataset, we&amp;rsquo;ll use PHATE.&lt;/p&gt;

&lt;h2 id=&#34;2-0-what-is-a-visualization&#34;&gt;2.0 - What is a visualization?&lt;/h2&gt;

&lt;p&gt;Before we get too deep into showing a bunch of plots, I want to spend a little time discussing visualizations. Skip ahead if you want, but I think it&amp;rsquo;s important to understand what a visualization is, and what you can or cannot get from it.&lt;/p&gt;

&lt;h4 id=&#34;a-visualization-is-a-reduction-of-dimensions&#34;&gt;A visualization is a reduction of dimensions&lt;/h4&gt;

&lt;p&gt;When we talk about data, we often consider the number of observations and the number of dimensions. In single cell RNA-seq, the number of observations is the number of cells in a dataset. In other words, this is the number of rows. The number of dimensions, or number of features, is the number of genes. These are the columns in a gene expression matrix.&lt;/p&gt;

&lt;p&gt;In a common experiment you might have 15,000-30,000 genes in a dataset measured across 5,000-100,000 cells. This presents a problem: How do you visually inspect such a dataset? The key is to figure out a way how to draw the relationships between points on a 2-dimensional sheet of paper, or if you add linear perspective, you can squeeze in a third dimension.&lt;/p&gt;

&lt;p&gt;A visualization is simply figuring out how to go from 30,000 dimensions -&amp;gt; 2-3.&lt;/p&gt;

&lt;h4 id=&#34;heatmaps-allow-you-to-look-at-all-genes-across-all-cells-simultaneously&#34;&gt;Heatmaps allow you to look at all genes across all cells simultaneously&lt;/h4&gt;

&lt;p&gt;One way is to look at a heatmap. Here I&amp;rsquo;ve created a clustered heatmap from the Datlinger data using &lt;code&gt;seaborn.clustermap&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import seaborn as sns
cg = sns.clustermap(t_cell_data, cmap=&#39;inferno&#39;, xticklabels=[], yticklabels=[])
cg.ax_heatmap.set_xlabel(&#39;Genes ({})&#39;.format(t_cell_data.shape[1]))
cg.ax_heatmap.set_ylabel(&#39;Cells ({})&#39;.format(t_cell_data.shape[0]))
&lt;/code&gt;&lt;/pre&gt;




&lt;figure class=&#34;img-lg&#34;&gt;

&lt;img src=&#34;https://dburkhardt.github.io/img/how_to_single_cell/datlinger_heatmap.png&#34; /&gt;


&lt;/figure&gt;

&lt;p&gt;It&amp;rsquo;s hard to draw any conclusions from this. How close together are any two cells? How do genes covary? We get some sense of this, and we are getting to look at all genes across all cells, but this representation of the data hinders hypothesis generation.&lt;/p&gt;

&lt;h4 id=&#34;biplots-show-gene-gene-relationships&#34;&gt;Biplots show gene-gene relationships&lt;/h4&gt;

&lt;p&gt;Another natural presentation is the biplot, commonly used for FACS analysis. Here each axis represents the expression of one of two genes and each dot is a cell. Let&amp;rsquo;s look at a biplot for some genes from the Datlinger dataset.&lt;/p&gt;

&lt;p&gt;As you can see, it&amp;rsquo;s much easier to identify gene-gene relationships, but you can see how complex a plot we get when we look at only a handful of genes. Now realize that there are 312 million pairwise combinations of genes in a 25,000 gene genome.&lt;/p&gt;




&lt;figure class=&#34;img-xl&#34;&gt;

&lt;img src=&#34;https://dburkhardt.github.io/img/how_to_single_cell/datlinger_pairplot.png&#34; /&gt;


&lt;/figure&gt;

&lt;p&gt;We need a better solution.&lt;/p&gt;

&lt;h3 id=&#34;why-can-we-reduce-dimensions&#34;&gt;Why can we reduce dimensions?&lt;/h3&gt;

&lt;p&gt;In biological systems, we know that some genes are related to each other. These relationships are complex and nonlinear, but we do know that not all possible combinations of gene expression are valid.&lt;/p&gt;




&lt;figure class=&#34;img-md&#34;&gt;

&lt;img src=&#34;https://dburkhardt.github.io/img/how_to_single_cell/ambient_latent_dim.png&#34; /&gt;


&lt;/figure&gt;

&lt;p&gt;On the left, points are uniformly distributed in the ambient 3-dimensional space. On the right, the points are randomly distributed on a 1-dimensional line that rolls in on itself. If we could unroll this line on the right, we would only need one or two dimensions to visualize it.&lt;/p&gt;

&lt;h4 id=&#34;how-can-we-reduce-dimensions&#34;&gt;How can we reduce dimensions?&lt;/h4&gt;

&lt;p&gt;There are many, many ways to visualize data. The most common ones are PCA, t-SNE, and MDS. Each of these has their own assumptions and simplifications they use to figure out an optimal 2D representation of high-dimensional data.&lt;/p&gt;

&lt;p&gt;PCA identifies linear combinations of genes such that each combination (called a Principal Component) that explains the maximum variance. t-SNE is a convex optimization algorithm that tries to minimize the divergence between the neighborhood distances of points (the distance between points that are &amp;ldquo;close&amp;rdquo;) in the low-dimensional representation and original data space.&lt;/p&gt;

&lt;p&gt;There are thousands of dimensionality reduction algorithms out there, and it&amp;rsquo;s important to understand that the drawbacks and benefits of each.&lt;/p&gt;

&lt;h2 id=&#34;2-1-visualizing-data-using-pca&#34;&gt;2.1 - Visualizing data using PCA&lt;/h2&gt;

&lt;h4 id=&#34;why-pca&#34;&gt;Why PCA?&lt;/h4&gt;

&lt;p&gt;I like to start out any scRNA-seq analysis by plotting a few principal components (PCs). First of all, we generally need to do PCA before doing any interesting downstream analysis, especially anything that involves graphs or matrices. Graphs are a mathematical representations of data as nodes and edges; more on that later.&lt;/p&gt;

&lt;p&gt;Doing multiplication or inversion of matrices with 1,000+ dimensions gets very slow and takes up a lot of memory so we typically only store 100-500 PCs and use this for downstream analysis. PCA gives us a quantification of how much variance we&amp;rsquo;ve lost by removing some of the final principal components. This means we can figure out how many we need to capture 99.999% of the variance in a dataset.&lt;/p&gt;

&lt;p&gt;Once we&amp;rsquo;ve calculated 100 PCs, we can just look at the first two to get a visualization.&lt;/p&gt;

&lt;h4 id=&#34;pca-dimensionality-reduction-using-scprep&#34;&gt;PCA dimensionality reduction using &lt;code&gt;scprep&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;By now you should know to expect that we&amp;rsquo;ve done the leg work here. You can easily perform PCA on any dataset using &lt;a href=&#34;https://scprep.readthedocs.io/en/stable/reference.html#module-scprep.reduce&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;scprep.reduce.pca()&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;data_pcs = scprep.reduce.pca(data_sq, n_pca=100)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now this simple syntax hides some complexity, so let&amp;rsquo;s dive a little deeper. If you don&amp;rsquo;t care, you can skip ahead to the &amp;ldquo;visualizing PCA section&amp;rdquo;.&lt;/p&gt;

&lt;h4 id=&#34;using-the-sklearn-pca-operator&#34;&gt;Using the &lt;code&gt;sklearn&lt;/code&gt; PCA operator&lt;/h4&gt;

&lt;p&gt;Scikit-learn (&lt;code&gt;sklearn&lt;/code&gt;) is a machine learning toolkit for Python. It&amp;rsquo;s excellent. &lt;code&gt;sklearn&lt;/code&gt; functions are the backbone of &lt;code&gt;scprep&lt;/code&gt;, and we model our code to fit the &lt;code&gt;sklearn&lt;/code&gt; style. The developers of &lt;code&gt;sklearn&lt;/code&gt; published &lt;a href=&#34;https://arxiv.org/abs/1309.0238&#34; target=&#34;_blank&#34;&gt;an interesting paper on ArXiv&lt;/a&gt; about how their code is structured. Ιf you&amp;rsquo;re a machine learning programmer using Python, I&amp;rsquo;d recommend reading it.&lt;/p&gt;

&lt;p&gt;One of &lt;code&gt;sklearn&lt;/code&gt;&amp;rsquo;s fundamental units is the estimator class.  One extremely useful estimator is the &lt;a href=&#34;https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.PCA.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;PCA&lt;/code&gt;&lt;/a&gt; class.&lt;/p&gt;

&lt;p&gt;You can instantiate a PCA operator in one line:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;from sklearn.decomposition import PCA
pc_op = PCA()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And fitting it to data is just as easy:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;data_pcs = pc_op.fit_transform(data_sq)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here we&amp;rsquo;re fitting the estimator to the data (&lt;em&gt;i.e.&lt;/em&gt; calculating the &lt;a href=&#34;https://en.wikipedia.org/wiki/Principal_component_analysis&#34; target=&#34;_blank&#34;&gt;principal component loadings&lt;/a&gt;) and then transforming it (&lt;em&gt;i.e.&lt;/em&gt; projecting each point on those components).&lt;/p&gt;

&lt;p&gt;During fitting, information about the variance of each component is calculated and stores in the &lt;code&gt;pc_op&lt;/code&gt; object as the &lt;code&gt;explained_variance_&lt;/code&gt; attribute. We can inspect this using a scree plot.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;fig, ax = plt.subplots(1, figsize=(6,5))

# plot explained variance as a fraction of the total explained variance
ax.plot(pc_op.explained_variance_/pc_op.explained_variance_.sum())

# mark the 100th principal component
ax.axvline(100, c=&#39;k&#39;, linestyle=&#39;--&#39;)

ax.set_xlabel(&#39;PC index&#39;)
ax.set_ylabel(&#39;% explained variance&#39;)
ax.set_title(&#39;Scree plot&#39;)

fig.tight_layout()
&lt;/code&gt;&lt;/pre&gt;




&lt;figure class=&#34;img-md&#34;&gt;

&lt;img src=&#34;https://dburkhardt.github.io/img/how_to_single_cell/datlinger_screeplot.png&#34; /&gt;


&lt;/figure&gt;

&lt;p&gt;There are a few interesting things to note here. First, we see a distinct elbow point at around 50 PCs where the explained variance of each additional component drops significantly. This means that is we reduce the data to 100, 150, or 200 PCs, the marginal increase in explained variance is vanishingly smaller.&lt;/p&gt;

&lt;p&gt;So is 100 a good cutoff? Let&amp;rsquo;s see how much variance is captured with this many components:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;&amp;gt;&amp;gt;&amp;gt; pc_op.explained_variance_.cumsum()[100]/pc_op.explained_variance_.sum() * 100
20.333394141561936
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This means we&amp;rsquo;re capturing ~20% of the variance in these components. Beyond this point, we get a decreasing return in explained variance for each added component.&lt;/p&gt;

&lt;h4 id=&#34;how-to-show-that-adding-components-doesn-t-increase-useful-information&#34;&gt;How to show that adding components doesn&amp;rsquo;t increase useful information&lt;/h4&gt;

&lt;h2 id=&#34;2-2-visualizing-pca-for-exploratory-analysis&#34;&gt;2.2 Visualizing PCA for exploratory analysis&lt;/h2&gt;

&lt;p&gt;Now, I want to show why inspecting principal components is useful as a preliminary data analysis step. First, let&amp;rsquo;s consider the T-cell data from Datlinger &lt;em&gt;et al.&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;fig, ax = plt.subplots(1, figsize=(5,5))

ax.scatter(data_pcs[:,0], data_pcs[:,1], s=1)
ax.set_xlabel(&#39;PC1&#39;)
ax.set_ylabel(&#39;PC2&#39;)
ax.set_title(&#39;T-cell - PCA&#39;)

fig.tight_layout()
&lt;/code&gt;&lt;/pre&gt;




&lt;figure class=&#34;img-md&#34;&gt;

&lt;img src=&#34;https://dburkhardt.github.io/img/how_to_single_cell/datlinger.PCA.nocolor.png&#34; /&gt;


&lt;/figure&gt;

&lt;p&gt;Here, each point here is a cells and the x and y axis represent the projection of that cell onto each principal component. Generally speaking, this PCA plot is unremarkable. There are a few outlier cells in the upper right with high PC2 loadings. Later we might want to look into what those cells, but for now its not so many that we&amp;rsquo;re very concerned about it.&lt;/p&gt;

&lt;p&gt;To fully leverage the utility of PCA, let&amp;rsquo;s add a third dimension, color, to the plot. This way we can look at the distribution of library size, mitochondrial RNA, and cells from each sample.&lt;/p&gt;

&lt;p&gt;First, let&amp;rsquo;s look at the conditions:&lt;/p&gt;




&lt;figure class=&#34;img-md&#34;&gt;

&lt;img src=&#34;https://dburkhardt.github.io/img/how_to_single_cell/datlinger.PCA.condition.png&#34; /&gt;


&lt;/figure&gt;

&lt;p&gt;Here we can see that in the first two principal components, there is a good amount of overlap between the two conditions (stimulated and unstimulated). At this point, we can&amp;rsquo;t make many conclusions about the relationship between these conditions. We see that the range of cells states between samples is similar. We also observe that PC2 is associated somewhat with the condition label. Most importantly we don&amp;rsquo;t observe a batch effect separating the two samples.&lt;/p&gt;

&lt;h2 id=&#34;2-3-identifying-batch-effects-using-pca&#34;&gt;2.3 Identifying batch effects using PCA&lt;/h2&gt;

&lt;p&gt;Compare the above plot to the following samples of mouse macrophage progenitors (unpublished). Here the first component visibily separates Sample 0 from Samples 1 &amp;amp; 2.&lt;/p&gt;




&lt;figure class=&#34;img-md&#34;&gt;

&lt;img src=&#34;https://dburkhardt.github.io/img/how_to_single_cell/visualization.PCA.batch_effect.png&#34; /&gt;


&lt;/figure&gt;

&lt;p&gt;There is some mixing, but most of the cells in Sample 0 closest neighbors in the plot are all from the same sample. Compare this to Samples 1 &amp;amp; 2 where there are many cells from each sample that have both neighbors from Sample 1 and Sample 2.&lt;/p&gt;

&lt;p&gt;In this dataset, we would say that there is some kind of batch effect between Sample 0 and Samples 1 &amp;amp; 2, but not between Samples 1 &amp;amp; 2. Note: I say batch effect here, but this does not mean that the shift is purely technical. In fact in this dataset, Sample 0 and Samples 1 &amp;amp; 2 are from different days of development.&lt;/p&gt;

&lt;h2 id=&#34;2-4-when-separation-doesn-t-imply-batch-effect&#34;&gt;2.4 When separation doesn&amp;rsquo;t imply batch effect&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s contrast this to a different dataset from from  &lt;a href=&#34;https://www.ncbi.nlm.nih.gov/pubmed/27565351&#34; target=&#34;_blank&#34;&gt;Shekhar, K. et al. (2018) &lt;em&gt;Comprehensive Classification of Retinal Bipolar Neurons by Single-Cell Transcriptomics.&lt;/em&gt; Cell 166, 1308-1323.e30 (2016)&lt;/a&gt;. Here, ~25,000 retinal bipolar cells were profiled using &lt;a href=&#34;https://www.ncbi.nlm.nih.gov/pubmed/26000488&#34; target=&#34;_blank&#34;&gt;the Dropseq protocol&lt;/a&gt;. I picked this dataset because it profiles many different cell types from a terminally differentiated tissue, the adult mouse retina.&lt;/p&gt;

&lt;p&gt;Here, we also see multiple groups of cells, but in each cloud there is approximately equal representation of each of 6 replicates.&lt;/p&gt;




&lt;figure class=&#34;img-md&#34;&gt;

&lt;img src=&#34;https://dburkhardt.github.io/img/how_to_single_cell/retinal_bipolar.PCA.samples.png&#34; /&gt;


&lt;/figure&gt;

&lt;p&gt;Rather, each cloud is associated with one or several annotated cell types from the paper.&lt;/p&gt;




&lt;figure class=&#34;img-md&#34;&gt;

&lt;img src=&#34;https://dburkhardt.github.io/img/how_to_single_cell/retinal_bipolar.PCA.cell_types.png&#34; /&gt;


&lt;/figure&gt;

&lt;h2 id=&#34;2-5-pca-confirms-ordering-of-samples-in-a-timecourse&#34;&gt;2.5 PCA confirms ordering of samples in a timecourse&lt;/h2&gt;

&lt;p&gt;Finally, let&amp;rsquo;s consider samples from a single cell time course of human embryoid bodies (EBs) profiled in collaboration between our lab and the Ivanova laboratory at Yale. This dataset is described in the PHATE manuscript. This time course is a useful comparison to the Shekar Bipolar dataset because here we&amp;rsquo;re looking at a developing system that is also composed of many different lineages of stem, precursor, and progenitor cell types. This dataset is publicly available at &lt;a href=&#34;https://data.mendeley.com/datasets/v6n743h5ng/1&#34; target=&#34;_blank&#34;&gt;Mendeley Data&lt;/a&gt;.&lt;/p&gt;




&lt;figure class=&#34;img-md&#34;&gt;

&lt;img src=&#34;https://dburkhardt.github.io/img/how_to_single_cell/embryoid.PCA.timepoint.png&#34; /&gt;


&lt;/figure&gt;

&lt;p&gt;Here we can see that the first principal component is tracking with the time of collection for each sample. The ordering of these samples matches the ordering of developmental time. This is expected and encouraging.&lt;/p&gt;

&lt;h2 id=&#34;2-6-examining-the-distribution-of-library-size&#34;&gt;2.6 Examining the distribution of library size&lt;/h2&gt;

&lt;p&gt;Now, let&amp;rsquo;s look at the library size.&lt;/p&gt;




&lt;figure class=&#34;img-md&#34;&gt;

&lt;img src=&#34;https://dburkhardt.github.io/img/how_to_single_cell/datlinger.PCA.libsize.png&#34; /&gt;


&lt;/figure&gt;

&lt;p&gt;This plot shows us that PC1, the linear combination of genes with the highest variance, is strongly associated with library size. If we plot just those two factors, we can see the strength of that association.&lt;/p&gt;




&lt;figure class=&#34;img-md&#34;&gt;

&lt;img src=&#34;https://dburkhardt.github.io/img/how_to_single_cell/datlinger.PCA.pc1_vs_libsize.png&#34; /&gt;


&lt;/figure&gt;

&lt;p&gt;This shows us that the log-library size is generating most of the variance in the dataset. This indicates that we might want to filter on library size more stringently. However, this is not highly unusual. We can keep this information in our back pockets for now, and move on.&lt;/p&gt;

&lt;p&gt;Now let&amp;rsquo;s look at the EB and retinal bipolar data:&lt;/p&gt;




&lt;figure class=&#34;img-md&#34;&gt;

&lt;img src=&#34;https://dburkhardt.github.io/img/how_to_single_cell/embryoid.PCA.libsize.png&#34; /&gt;


&lt;/figure&gt;

&lt;p&gt;Again, we see a similar trend between PC1 and library size. However, this isn&amp;rsquo;t always the case.&lt;/p&gt;




&lt;figure class=&#34;img-md&#34;&gt;

&lt;img src=&#34;https://dburkhardt.github.io/img/how_to_single_cell/retinal_bipolar.PCA.libsize.png&#34; /&gt;


&lt;/figure&gt;

&lt;p&gt;In this dataset we can see that there are cells in each point cloud with high library size. Now you might wonder, when can we see that there&amp;rsquo;s an issue by looking at PCs and library size?&lt;/p&gt;

&lt;h2 id=&#34;2-7-when-principal-components-separate-cells-by-library-size&#34;&gt;2.7 When principal components separate cells by library size&lt;/h2&gt;

&lt;p&gt;The following dataset is from a published paper comparing mutant and wild-type conditions. Inspecting the data via PCA clearly shows two populations of cells separated by PC1. Unlike the previous example of batch effect, these populations contain an equal number of cells from each sample. This leads us to refer to this artifact as a within-batch effect.&lt;/p&gt;




&lt;figure class=&#34;img-md&#34;&gt;

&lt;img src=&#34;https://dburkhardt.github.io/img/how_to_single_cell/zebrafish.PCA.libsize.png&#34; /&gt;


&lt;/figure&gt;

&lt;p&gt;As you can see, the distribution of library sizes in the right populations is much higher than on the left. In the next plot, I did KMeans on the first 100 PCs to extract the clusters. We&amp;rsquo;ll discuss clustering more later, but this hack worked to separate the populations so that we could look at the library size.&lt;/p&gt;




&lt;figure class=&#34;img-md&#34;&gt;

&lt;img src=&#34;https://dburkhardt.github.io/img/how_to_single_cell/zebrafish.PCA.clusters.png&#34; /&gt;


&lt;/figure&gt;

&lt;p&gt;Now this experiment wasn&amp;rsquo;t performed in our lab or by one of our collaborators so we&amp;rsquo;re not entirely sure what&amp;rsquo;s going on here. One guess is that the cells on the left are of poor quality and have less RNA. Another is that they are from a different batch than those on the right. We&amp;rsquo;ve reached out to the original lab that created this data, and they seemed as stumped as we were.&lt;/p&gt;

&lt;p&gt;At this point, you might seriously consider throwing out the cells with lower library size.&lt;/p&gt;

&lt;h2 id=&#34;2-8-examining-mitochondrial-rna-expression&#34;&gt;2.8 Examining mitochondrial RNA expression&lt;/h2&gt;

&lt;p&gt;I don&amp;rsquo;t want to spend too much time on this, but just as we looked at library size above, you should plot mitochondrial RNA expression on a PCA plot.&lt;/p&gt;

&lt;p&gt;Generally, you want the mitochondrial expression to look something like this:&lt;/p&gt;




&lt;figure class=&#34;img-md&#34;&gt;

&lt;img src=&#34;https://dburkhardt.github.io/img/how_to_single_cell/datlinger.PCA.mito_exp.png&#34; /&gt;


&lt;/figure&gt;

&lt;p&gt;Here, the cells with the highest mitochondrial expression are generally evenly distributed on the plot. This is a good indication that you&amp;rsquo;ve done a good job filtering mitochondrial genes.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3. Visualizing data using PHATE</title>
      <link>https://dburkhardt.github.io/tutorial/visualizing_phate/</link>
      <pubDate>Sun, 09 Sep 2018 00:00:00 -0400</pubDate>
      
      <guid>https://dburkhardt.github.io/tutorial/visualizing_phate/</guid>
      <description>

&lt;p&gt;Once you&amp;rsquo;ve inspected the principle components of your dataset, it&amp;rsquo;s time to start visualizing your data using PHATE. We&amp;rsquo;re going to demonstrate PHATE analysis on a few datasets. We will show:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;How PHATE works&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Running PHATE on several datasets&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;How to interpret a PHATE plot&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Clustering using the diffusion potential&lt;/li&gt;
&lt;li&gt;How to pick parameters for PHATE&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;How to troubleshoot common issues with PHATE plots&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;3-0-what-is-phate-and-why-should-you-use-it&#34;&gt;3.0 - What is PHATE and why should you use it?&lt;/h2&gt;

&lt;p&gt;PHATE is a dimensionaltiy reduction developed by the Krishnaswamy lab for visualizing high-dimensional data. We use PHATE for &lt;em&gt;every&lt;/em&gt; dataset the comes through the lab: scRNA-seq, CyTOF, gut microbiome profiles, simulated data, etc. PHATE was designed to handle noisy, non-linear relationships between data points. PHATE produces a low-dimensional representation that preserves both local and global structure in a dataset so that you can make generate hypotheses from the plot about the relationships between cells present in a dataset. Although PHATE has utility for analysis of many data modalities, we will focus on the application of PHATE for scRNA-seq analysis.&lt;/p&gt;

&lt;p&gt;PHATE is inspired by diffusion maps &lt;a href=&#34;https://doi.org/10.1016/j.acha.2006.04.006&#34; target=&#34;_blank&#34;&gt;(Coifman et al. (2008))&lt;/a&gt;, but include several key innovations that make it possible to generate a two or three dimensional visualization that preserves continuous relationships between cells where they exist. For a full explanation of the PHATE algorithm, please consult &lt;a href=&#34;https://doi.org/10.1101/120378&#34; target=&#34;_blank&#34;&gt;the PHATE manuscript&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;installing-phate&#34;&gt;Installing PHATE&lt;/h3&gt;

&lt;p&gt;PHATE is available on PyPI, and can be installed by running the following command in a terminal:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;$ pip install --user phate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;PHATE is also available in &lt;code&gt;MATLAB&lt;/code&gt; and &lt;code&gt;R&lt;/code&gt;, but we&amp;rsquo;re going to focus on the Python implementation for this tutorial.&lt;/p&gt;

&lt;h2 id=&#34;3-1-phate-parameters&#34;&gt;3.1 PHATE parameters&lt;/h2&gt;

&lt;p&gt;As we mentioned in the previous section, PHATE is a subclass of the &lt;code&gt;sklearn.BaseEstimator&lt;/code&gt;, and it&amp;rsquo;s API matches that of the &lt;code&gt;PCA&lt;/code&gt; operator. To use PHATE, you must first instantiate a &lt;code&gt;phate.PHATE&lt;/code&gt; object, and then use &lt;code&gt;fit_transform&lt;/code&gt; to build a graph to your data and reduce the dimensionality of the data for visualization.&lt;/p&gt;

&lt;p&gt;PHATE has three key parameters:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;n_components&lt;/code&gt; - sets the number of dimensions to which PHATE will reduce the input data&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;knn&lt;/code&gt; - sets the number of Nearest Neighbors to use for calculating the kernel bandwidth&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;decay&lt;/code&gt; - sets the rate of decay of the kernel tails&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I&amp;rsquo;ll introduce other parameters thoughout the tutorial, but you should also check out the full documentation on readthedocs: &lt;a href=&#34;https://phate.readthedocs.io/en/stable/&#34; target=&#34;_blank&#34;&gt;https://phate.readthedocs.io/en/stable/&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;3-2-wait-a-second-what-s-a-kernel&#34;&gt;3.2 &lt;em&gt;Wait a second, what&amp;rsquo;s a kernel?&lt;/em&gt;&lt;/h2&gt;

&lt;p&gt;Now if you&amp;rsquo;ve never studied graph theory or discrete mathematics, these last two parameters might be confusing. To understand them, consider a very simple graph, the k-Nearest Neighbor (kNN) graph. Here, each cell is a node in the graph, and edges exist between a cell and it&amp;rsquo;s &lt;code&gt;k&lt;/code&gt; nearest neighbors. You can also think about this as a graph where all cells are connected, but the connections between non-neighboring cells have a &lt;em&gt;strength&lt;/em&gt; or &lt;em&gt;weight&lt;/em&gt; of 0, while the edges between neighboring cells have a weight of 1.&lt;/p&gt;

&lt;p&gt;The kNN graph offers a very powerful representation for single cell data, but it also has some drawbacks. For example, consider the following graphs:&lt;/p&gt;




&lt;figure class=&#34;img-sm&#34;&gt;

&lt;img src=&#34;https://dburkhardt.github.io/img/how_to_single_cell/PHATE_graph_explanation.png&#34; /&gt;


&lt;/figure&gt;

&lt;p&gt;On the left, we have a kNN graph where &lt;em&gt;k&lt;/em&gt;=4. Notice that all the blue cells, regardless of their proximity to the red cell, have edges of equal weight. Also notice that the green cell in the lower right hand corner has no connection to the red cell, despite being only trivially farther away than the next closest cell. These two properties of kNN graphs, a harsh cutoff for edges and uniform edge weights, means that choice of proper &lt;code&gt;k&lt;/code&gt; is critical for any method using this graph.&lt;/p&gt;

&lt;p&gt;To overcome these limitations, we use a variation of the &lt;a href=&#34;https://en.wikipedia.org/wiki/Radial_basis_function_kernel&#34; target=&#34;_blank&#34;&gt;radial basis kernel&lt;/a&gt; graph on the right. This graph connects cells with edge weights proportionally to their distance to the red cell. You can think of this kernel function as a &amp;ldquo;soft&amp;rdquo; kNN, where the weights vary smoothly between 0 and 1. Note: in practice, all cells are connected at one stage during graph instantiation, but then edges that are below a cutoff, such as &lt;code&gt;1e-4&lt;/code&gt; are set to 0.&lt;/p&gt;

&lt;p&gt;Now that you understand this distinction, you can think of the &lt;code&gt;knn&lt;/code&gt; parameter as setting a baseline for finding close cells, and &lt;code&gt;decay&lt;/code&gt; as the &amp;ldquo;softness&amp;rdquo; the edge weighting.&lt;/p&gt;

&lt;h2 id=&#34;3-3-instantiating-a-phate-estimator&#34;&gt;3.3  Instantiating a PHATE estimator&lt;/h2&gt;

&lt;p&gt;In practice, I usually start by running PHATE on a new dataset with default parameters, which is &lt;code&gt;n_components=2&lt;/code&gt;, &lt;code&gt;knn=5&lt;/code&gt;, and &lt;code&gt;decay=40&lt;/code&gt;. Rarely, I will want to change these, but we will cover parameter tuning in a later section.&lt;/p&gt;

&lt;p&gt;We can create a new &lt;code&gt;PHATE&lt;/code&gt; object just like we did with the &lt;code&gt;PCA&lt;/code&gt; class:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import phate
phate_op = phate.PHATE()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and now we can generate an embedding by calling &lt;code&gt;fit_transform&lt;/code&gt; and plot the output using &lt;code&gt;scprep.plot.scatter2d&lt;/code&gt;. Let&amp;rsquo;s start with the T cell data from Datlinger et al. (2017).&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;Y = phate_op.fit_transform(data_sq)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note: you can also pass in the PCA-reduced data from earlier, but PHATE can also do this for you at the cost of increased compute time.&lt;/p&gt;

&lt;p&gt;You&amp;rsquo;ll see some output that looks like this, telling you that PHATE is doing stuff:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Calculating PHATE...
  Calculating graph and diffusion operator...
    Calculating PCA...
    Calculated PCA in 4.20 seconds.
    Calculating KNN search...
    Calculated KNN search in 1.23 seconds.
    Calculating affinities...
    Calculated affinities in 0.18 seconds.
  Calculated graph and diffusion operator in 6.20 seconds.
  Calculating landmark operator...
    Calculating SVD...
    Calculated SVD in 0.51 seconds.
    Calculating KMeans...
    Calculated KMeans in 14.68 seconds.
  Calculated landmark operator in 16.57 seconds.
  Calculating optimal t...
    Automatically selected t = 28
  Calculated optimal t in 0.80 seconds.
  Calculating diffusion potential...
  Calculated diffusion potential in 0.45 seconds.
  Calculating metric MDS...
  Calculated metric MDS in 33.45 seconds.
Calculated PHATE in 57.48 seconds.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note, these times with setting &lt;code&gt;n_jobs=16&lt;/code&gt;, you may find slower performance on a laptop or when using sparse input.&lt;/p&gt;

&lt;h2 id=&#34;3-4-plotting-phate-with-a-scatter-plot&#34;&gt;3.4 Plotting PHATE with a scatter plot&lt;/h2&gt;

&lt;p&gt;Now we can plot using &lt;code&gt;scatter2d&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;scprep.plot.scatter2d(Y, ticks=None, label_prefix=&#39;PHATE&#39;, figsize=(5,5))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And see the following plot:&lt;/p&gt;




&lt;figure class=&#34;img-md&#34;&gt;

&lt;img src=&#34;https://dburkhardt.github.io/img/how_to_single_cell/PHATE.tcell.nocolor.png&#34; /&gt;


&lt;/figure&gt;

&lt;p&gt;From this plot, we can tell that there are several kinds of cells in the data set, but it&amp;rsquo;s hard to tell much other than that without starting to add some color. Let&amp;rsquo;s plot the condition label for each cell, the library size, and expression of a mitochonrial gene.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# Plotting mitochondrial expression
fig, ax = plt.subplots(1, figsize=(3.4,3))
scprep.plot.scatter2d(Y, ax=ax, c=t_cell_data_ln[&#39;MT-CO1&#39;],
                      title=&#39;MT-CO1&#39;, ticks=False, label_prefix=&#39;PHATE&#39;)
fig.tight_layout()

# Plotting libsize
fig, ax = plt.subplots(1, figsize=(3.6,3))
scprep.plot.scatter2d(Y, ax=ax, c=metadata[&#39;library_size&#39;],
                      title=&#39;Library Size&#39;, ticks=False, label_prefix=&#39;PHATE&#39;)
fig.tight_layout()

# Plotting condition label
fig, ax = plt.subplots(1, figsize=(4.4,3))
condition_cdict = {&#39;stimulated&#39;:&#39;#1a3263&#39;,
                   &#39;unstimulated&#39;:&#39;#f5564e&#39;}
scprep.plot.scatter2d(Y, ax=ax, c=metadata[&#39;condition&#39;], cmap=condition_cdict,
                      title=&#39;Condition&#39;, ticks=False, label_prefix=&#39;PHATE&#39;,
                     legend_anchor=(1,1))
fig.tight_layout()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And we see the following plots:&lt;/p&gt;




&lt;figure class=&#34;img-lg&#34;&gt;

&lt;img src=&#34;https://dburkhardt.github.io/img/how_to_single_cell/PHATE.tcell.colors.png&#34; /&gt;


&lt;/figure&gt;

&lt;p&gt;Examining these plots, we see that there are no regions enriched for high mitochondrial RNA (which would indicate apoptotic cells). Although there are some regions of the plot with higher library size than others, these cells are fairly well distributed over the plot. If we say a branch of cells shooting off the plot with very high or low library sizes, then we might want to revisit the filtering thresholds established during preprocessing.&lt;/p&gt;

&lt;p&gt;Finally, when we examine the the distribution of condition labels, we see that there is a good amount of overlap between the two conditions. We&amp;rsquo;ll get to characterizing the differences between these two conditions in a later tutorial. For now, check out our method, MELD (Manifold Enhancement of Latent Dimensions) on &lt;a href=&#34;https://doi.org/10.1101/532846&#34; target=&#34;_blank&#34;&gt;BioRxiv (doi: &lt;code&gt;10.1101/532846&lt;/code&gt;)&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;3-5-plotting-phate-as-a-kde-plot&#34;&gt;3.5 Plotting PHATE as a KDE plot&lt;/h2&gt;

&lt;p&gt;Scatter plots are a useful way to display data. They also have the appeal of showing you every single point in your dataset. &lt;em&gt;Or do they?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Scatter plots have one drawback, which is that data points that are overlapping in the plot get drawn on top of each other. This makes it difficult to identify where most of the data density lies. You could color your plot by a density estimate, as is commonly done in FACS analysis. However, I find that in these plots, the eye is still drawn to outliers.&lt;/p&gt;

&lt;p&gt;Instead, I think it&amp;rsquo;s useful to look at a Kernel Density Estimate (KDE) plot. These plots use kernel functions (just like in the graph building process) to estimate data density in one or more dimensions.&lt;/p&gt;

&lt;p&gt;In python you can make a KDE plot using the &lt;a href=&#34;https://seaborn.pydata.org/&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;seaborn&lt;/code&gt;&lt;/a&gt; package. &lt;code&gt;seaborn&lt;/code&gt; works seamlessly with &lt;code&gt;numpy&lt;/code&gt; and &lt;code&gt;pandas&lt;/code&gt; and uses &lt;code&gt;matplotlib&lt;/code&gt; as a backend. The function for drawing a KDE plot is called, unsurprisingly &lt;code&gt;kdeplot&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s generate a KDE plot of the T cell data to get an idea of how many clusters of cells are in the data.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import seaborn as sns

fig, ax = plt.subplots(1, figsize=(4,4))
sns.kdeplot(Y[:,0], Y[:,1], n_levels=100, shade=True, cmap=&#39;inferno&#39;, zorder=0, ax=ax)

ax.set_xticks([])
ax.set_yticks([])

ax.set_xlabel(&#39;PHATE 1&#39;, fontsize=18)
ax.set_ylabel(&#39;PHATE 2&#39;, fontsize=18)

ax.set_title(&#39;KDE - T cells&#39;, fontsize=20)

fig.tight_layout()
&lt;/code&gt;&lt;/pre&gt;




&lt;figure class=&#34;img-md&#34;&gt;

&lt;img src=&#34;https://dburkhardt.github.io/img/how_to_single_cell/PHATE.KDE.tcell.png&#34; /&gt;


&lt;/figure&gt;

&lt;p&gt;Here, it&amp;rsquo;s much easier to see that there are around 5 regions of density in the data. Let&amp;rsquo;s cluster them and figure out what they are!&lt;/p&gt;

&lt;h2 id=&#34;3-6-clustering-data-using-phate&#34;&gt;3.6 Clustering data using PHATE&lt;/h2&gt;

&lt;p&gt;A common mode of analysis for scRNA-seq is to identify clusters of cells and characterize the transcriptional diversity of these subpopulations. There are many clustering algorithms out there, and many of them have implementations in &lt;a href=&#34;https://scikit-learn.org/stable/modules/clustering.html#clustering&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;sklearn.cluster&lt;/code&gt;&lt;/a&gt;. One of our favorite clustering algorithms is &lt;a href=&#34;https://link.springer.com/article/10.1007/s11222-007-9033-z&#34; target=&#34;_blank&#34;&gt;Spectral Clustering&lt;/a&gt;. In the PHATE package, we have developed an adaptation of this method using the PHATE diffusion potential instead of the eigenvectors of the normalized Laplacian.&lt;/p&gt;

&lt;p&gt;You can call this method with &lt;code&gt;phate.cluster.kmeans&lt;/code&gt;, and use these labels to color the PHATE plot. We&amp;rsquo;ll set &lt;code&gt;k=5&lt;/code&gt; based on our examination of the KDE plot.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;clusters = phate.cluster.kmeans(phate_op, k=5)

scprep.plot.scatter2d(Y, c=clusters, cmap=sns.husl_palette(5), s=1,
                      figsize=(4.3,4), ticks=None, label_prefix=&#39;PHATE&#39;,
                     legend_anchor=(1,1), fontsize=12, title=&#39;PHATE clusters&#39;)

fig.tight_layout()
&lt;/code&gt;&lt;/pre&gt;




&lt;figure class=&#34;img-md&#34;&gt;

&lt;img src=&#34;https://dburkhardt.github.io/img/how_to_single_cell/PHATE.tcell.clusters.png&#34; /&gt;


&lt;/figure&gt;

&lt;p&gt;Here, we can see that the clusters are localized on the PHATE plot, and now we can begin to characterize them. Note, I won&amp;rsquo;t claim that this is the best method for identifying clusters. In general, cluster assignments should be seen as &amp;ldquo;best guess&amp;rdquo; partitions of the data. For every clustering algorithm, you can change some parameters and increase or decrease the number of clusters identified. The best way to make sure you have &amp;ldquo;valid&amp;rdquo; clusters is to inspect each group individually, and make sure you&amp;rsquo;re happy with the resolution of the results.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
